<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="For Wolfgang.">
    <meta name="author" content="Zack Gort">
    
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ifimaybefrank.com">
    <link rel="canonical" href="https://ifimaybefrank.com">
    <meta property="og:title" content="Wolfgang">
    <meta property="og:description" content="For Wolfgang.">
    <meta property="og:image" content="https://ifimaybefrank.com/og-image.jpg">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Wolfgang">
    <meta property="twitter:description" content="For Wolfgang.">
    <meta property="twitter:image" content="https://ifimaybefrank.com/og-image.jpg">
    
    <title>Wolfgang</title>
    <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAAAIAA8AQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAQAAAAEAgGAAAAH/P/YQAAAQNJREFUeJxjYKAQMMIYlzJ5/qNL6k3/wkhIjgWmQCFQh4GBgYGBjZmRgZ2dmeHnz78Mlxgu/2dgYGCAySGDSwxX/utN/8LIyMDAwPBynQncBlEuFgZGDQGG/zc+MLz+9gev88WDzjCyMDAwMHz/ilD44sdfBv6zbxg+/vzL8OsvhssxAMSALwgDvjMwMHxk+E1QI6oBX/E7lSQXkArg0binVJGwh5GAS/d9RhQDGBgYGDZnyhJliO/0x3B9jOiSq+Ik8RoStug5ih4MAxgYGBgWBoliNSR+3WsM9VgNYGBgYJjhLohiSMbO9zjV4gT91rz/+6158XqJBZ/k969/SbaUZAAABDJTRS3nencAAAAASUVORK5CYII=" sizes="any">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPGRlZnM+CiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9ImhnIiBjeD0iNDIlIiBjeT0iMzUlIiByPSI2NSUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjZjBiODQwIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iNTUlIiBzdG9wLWNvbG9yPSIjZDQ4ODBhIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iIzhiNGEwMCIvPgogICAgPC9yYWRpYWxHcmFkaWVudD4KICAgIDxmaWx0ZXIgaWQ9InNvZnQiPgogICAgICA8ZmVHYXVzc2lhbkJsdXIgaW49IlNvdXJjZUFscGhhIiBzdGREZXZpYXRpb249IjAuNSIgcmVzdWx0PSJibHVyIi8+CiAgICAgIDxmZUNvbXBvc2l0ZSBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyIiBvcGVyYXRvcj0ib3ZlciIvPgogICAgPC9maWx0ZXI+CiAgPC9kZWZzPgogIDwhLS0gSGVhcnQgcGF0aCBjZW50ZXJlZCBpbiAzMngzMiwgc2xpZ2h0bHkgb3JnYW5pYyBwcm9wb3J0aW9ucyAtLT4KICA8cGF0aCBmaWx0ZXI9InVybCgjc29mdCkiCiAgICBkPSJNMTYgMjcuMiBDMTYgMjcuMiA0IDE5LjIgNCAxMS42IEM0IDcuNCA3LjIgNCAxMS4yIDQgQzEzLjQgNCAxNS4yIDUuMiAxNiA2LjIgQzE2LjggNS4yIDE4LjYgNCAyMC44IDQgQzI0LjggNCAyOCA3LjQgMjggMTEuNiBDMjggMTkuMiAxNiAyNy4yIDE2IDI3LjJaIgogICAgZmlsbD0idXJsKCNoZykiCiAgLz4KPC9zdmc+" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,500;0,600;1,400&family=Space+Mono:wght@400;700&family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
/* ===================================
   CSS VARIABLES & THEMES
   =================================== */
   :root {
    /* ── Palette ── */
    --bg-color: #000000;
    --ink: #ffffff;
    --ink-2: #b8b8b8;
    --ink-3: #808080;
    --accent: #daa520;

    /* ── Semantic surfaces ── */
    --surface: rgba(0, 0, 0, 0.60);           /* widget/panel bg */
    --surface-raised: rgba(10, 10, 10, 0.95); /* dropdowns, overlays */
    --border: rgba(255, 255, 255, 0.10);
    --border-strong: rgba(255, 255, 255, 0.15);
    --glass-border: rgba(255, 255, 255, 0.10);
    --hover-tint: rgba(218, 165, 32, 0.08);   /* accent-tinted hover */
    --hover-tint-strong: rgba(218, 165, 32, 0.15);

    /* ── Sentence states ── */
    --sentence-color: rgba(255, 255, 255, 0.85);
    --sentence-active-color: #ffffff;
    --sentence-active-bg: rgba(0, 0, 0, 0.95);
    --sentence-active-shadow: 0 0 20px rgba(218, 165, 32, 0.30);
    --sentence-hover-color: var(--ink);
    --sentence-hover-bg: rgba(218, 165, 32, 0.08);
    --sentence-dimmed-opacity: 0.5;
    --sentence-dimmed-color: rgba(255, 255, 255, 0.50);

    /* ── Typography ── */
    --ui-font: 'Space Mono', monospace;
    --body-font: 'Crimson Text', Georgia, serif;
    --stream-line-height: 1.8;
    --stream-letter-spacing: -0.01em;
    --ui-font-weight: 400;
    --chapter-break-weight: 700;
    --chapter-break-letter-spacing: 0.15em;
    --chapter-break-font-size: 11px;
    --chapter-break-border-width: 1px;

    /* ── Chapter progress bars ── */
    --chapter-bar-bg: rgba(255, 255, 255, 0.15);
    --chapter-bar-hover-bg: rgba(255, 255, 255, 0.30);
    --chapter-bar-completed-bg: rgba(218, 165, 32, 0.40);
    --chapter-bar-completed-hover-bg: rgba(218, 165, 32, 0.60);
    --chapter-tooltip-bg: rgba(0, 0, 0, 0.90);

    /* ── Image grid ── */
    --grid-overlay-bg: rgba(5, 5, 5, 0.96);
    --grid-item-bg: #111111;
    --grid-item-border: rgba(255, 255, 255, 0.10);
    --grid-title-border: rgba(255, 255, 255, 0.10);

    /* ── Effects ── */
    --vig-opacity: 0.85;
    --vig-inner: 30%;
    --vig-mid: 75%;
    --vig-outer: 100%;
    --edge-blur: 6px;
    --edge-mask-i: 65%;
    --edge-mask-o: 80%;
    --grain-opacity: 0.08;
    --effects-display: block; /* set to 'none' to kill grain/vig/blur */

    /* ── Brackets ── */
    --bracket-color: #8b6f47;
    --bracket-hover: #daa520;
    --bracket-bg: rgba(218, 165, 32, 0.04);

    /* ── Cursor ── */
    --cursor-bg: transparent;
    --cursor-border: rgba(255, 255, 255, 0.50);
    --cursor-blend: difference;
    --cursor-opacity: 1;

    /* ── Selection ── */
    --selection-bg: rgba(218, 165, 32, 0.25);
    --selection-color: #ffffff;

    /* ── z-index stack ── */
    --z-content: 0;
    --z-grain: 149;
    --z-blur: 150;
    --z-vig: 151;
    --z-ui: 220;
    --z-overlay: 300;
    --z-dropdown: 350;
    --z-rail: 210;
    --z-mobile-bottom-rail: 220;
    --z-rotate-warning: 9999;

    /* ── Parallax ── */
    --text-parallax-strength: 0.03;
    --image-parallax-strength: 0.15;
    --center-magnet-strength: 0.25;
    --curve-k: 1;
}

/* ── NEWSPAPER THEME ── */
body.theme-newspaper {
    --bg-color: #faf8f3;
    --ink: #000000;
    --ink-2: #1a1a1a;
    --ink-3: #2a2a2a;
    --accent: #8b4513;

    --surface: rgba(245, 241, 232, 0.95);
    --surface-raised: rgba(245, 241, 232, 0.98);
    --border: rgba(0, 0, 0, 0.12);
    --border-strong: rgba(0, 0, 0, 0.15);
    --hover-tint: rgba(139, 69, 19, 0.06);
    --hover-tint-strong: rgba(139, 69, 19, 0.10);

    --sentence-color: #000000;
    --sentence-active-color: #ffffff;
    --sentence-active-bg: #000000;
    --sentence-active-shadow: none;
    --sentence-hover-color: #000000;
    --sentence-hover-bg: rgba(255, 255, 255, 0.95);
    --sentence-dimmed-opacity: 0.5;
    --sentence-dimmed-color: #333333;

    --chapter-bar-bg: rgba(0, 0, 0, 0.12);
    --chapter-bar-hover-bg: rgba(0, 0, 0, 0.25);
    --chapter-bar-completed-bg: rgba(139, 69, 19, 0.30);
    --chapter-bar-completed-hover-bg: rgba(139, 69, 19, 0.50);
    --chapter-tooltip-bg: rgba(245, 241, 232, 0.95);

    --grid-overlay-bg: rgba(245, 241, 232, 0.98);
    --grid-item-bg: #e8e4d8;
    --grid-item-border: rgba(0, 0, 0, 0.15);
    --grid-title-border: rgba(0, 0, 0, 0.12);

    --vig-opacity: 0.12;
    --grain-opacity: 0.08;

    --bracket-color: #5d4e37;
    --bracket-hover: #8b4513;
    --bracket-bg: rgba(139, 69, 19, 0.03);

    --cursor-bg: transparent;
    --cursor-border: rgba(0, 0, 0, 0.40);
    --cursor-blend: normal;
    --cursor-opacity: 1;

    --selection-bg: rgba(139, 69, 19, 0.25);
    --selection-color: #ffffff;
}

/* ── SPORT THEME ── */
body.theme-sport {
    --bg-color: #0a0a0a;
    --ink: #f5f5f5;
    --ink-2: #e0e0e0;
    --ink-3: #888888;
    --accent: #fa3c00;

    --surface: rgba(10, 10, 10, 0.92);
    --surface-raised: rgba(10, 10, 10, 0.97);
    --border: rgba(250, 60, 0, 0.18);
    --border-strong: rgba(250, 60, 0, 0.25);
    --hover-tint: rgba(250, 60, 0, 0.10);
    --hover-tint-strong: rgba(250, 60, 0, 0.15);

    --sentence-color: var(--ink-2);
    --sentence-active-color: #ffffff;
    --sentence-active-bg: var(--accent);
    --sentence-active-shadow: none;
    --sentence-hover-color: #ffffff;
    --sentence-hover-bg: rgba(250, 60, 0, 0.12);
    --sentence-dimmed-opacity: 0.5;
    --sentence-dimmed-color: var(--ink-3);

    --ui-font: 'Inter', sans-serif;
    --ui-font-weight: 600;
    --body-font: 'Inter', sans-serif;
    --stream-line-height: 1.75;
    --stream-letter-spacing: -0.025em;
    --chapter-break-weight: 900;
    --chapter-break-letter-spacing: 0.14em;
    --chapter-break-font-size: 10px;
    --chapter-break-border-width: 2px;

    --chapter-bar-bg: rgba(255, 255, 255, 0.10);
    --chapter-bar-hover-bg: rgba(255, 255, 255, 0.25);
    --chapter-bar-completed-bg: rgba(250, 60, 0, 0.35);
    --chapter-bar-completed-hover-bg: rgba(250, 60, 0, 0.55);
    --chapter-tooltip-bg: rgba(10, 10, 10, 0.97);

    --grid-overlay-bg: rgba(10, 10, 10, 0.98);
    --grid-item-bg: #111111;
    --grid-item-border: rgba(255, 255, 255, 0.08);
    --grid-title-border: rgba(250, 60, 0, 0.20);

    --vig-opacity: 0.60;
    --edge-blur: 4px;
    --grain-opacity: 0.04;

    --bracket-color: #cc3000;
    --bracket-hover: #fa3c00;
    --bracket-bg: rgba(250, 60, 0, 0.06);

    --cursor-bg: var(--accent);
    --cursor-border: var(--accent);
    --cursor-blend: normal;
    --cursor-opacity: 0.85;

    --selection-bg: rgba(250, 60, 0, 0.35);
    --selection-color: #ffffff;
}

/* ===================================
   LAYOUT MODES
   =================================== */
html, body { overscroll-behavior: none; touch-action: pan-y; }
body.layout-layered .text-layer { width: 95%; margin: 0 auto; max-width: 1400px; }
body.layout-layered .stream { color: var(--sentence-color); }
body.layout-layered .hover-image { position: absolute; left: 50%; top: 50%; }
body.layout-split .text-layer { width: 50%; margin: 0; padding-left: 6vw; }
body.layout-split .stream { color: var(--sentence-color); font-size: clamp(16px, 2vw, 28px); }
body.layout-split .hover-image { position: fixed; left: 72%; top: 50%; width: 45vw; height: 34vw; }
body.layout-split .hover-image.active { opacity: 1 !important; filter: brightness(1) contrast(1); }
body .hover-image { display: block; }

/* HIDE MOBILE RIGHT RAIL IN SPLIT VIEW */
body.layout-split .mobile-right-rail { display: none !important; }

/* ===================================
   KEYBOARD LEGEND WIDGET
   =================================== */
.keyboard-legend {
    position: fixed;
    bottom: 20px;
    right: 80px;
    z-index: var(--z-ui);
    display: flex;
    align-items: center;
    gap: 6px;
    background: var(--surface);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px 6px 4px;
    cursor: grab;
    user-select: none;
    transition: background 0.35s ease, border-color 0.35s ease;
    box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    touch-action: none;
    transform: translateZ(0);
    will-change: transform;
    isolation: isolate;
}
.keyboard-legend:active { cursor: grabbing; }
.drag-handle {
    font-family: sans-serif;
    color: var(--ink-3);
    font-size: 12px;
    line-height: 1;
    padding-right: 6px;
    border-right: 1px solid var(--border);
    opacity: 0.4;
    display: flex;
    align-items: center;
    height: 100%;
    letter-spacing: -3px;
}
.k-group { display: flex; flex-direction: column; gap: 3px; align-items: center; }
.k-row { display: flex; gap: 3px; }
.k-key {
    width: 22px; height: 22px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 3px;
    display: flex; align-items: center; justify-content: center;
    font-family: var(--ui-font);
    font-weight: var(--ui-font-weight);
    font-size: 11px; color: var(--ink-3);
    position: relative;
    transition: all 0.15s ease;
    cursor: pointer;
}
.k-key:hover { background: var(--accent); color: var(--bg-color); border-color: var(--accent); }
.k-key:active { transform: scale(0.88); }
.k-tooltip {
    position: absolute; bottom: 100%; left: 50%;
    transform: translateX(-50%) translateY(-6px);
    background: var(--surface-raised); color: var(--ink);
    padding: 3px 7px; border-radius: 3px; font-size: 9px;
    white-space: nowrap; opacity: 0; pointer-events: none;
    transition: opacity 0.15s ease;
    border: 1px solid var(--border);
    font-family: var(--ui-font);
    letter-spacing: 0.05em;
}
.k-key:hover .k-tooltip { opacity: 1; }

@media (max-width: 768px) { .keyboard-legend { display: none; } }

/* ===================================
   MODE CLUSTER WIDGET
   =================================== */
.mode-cluster {
    display: flex;
    align-items: center;
    gap: 3px;
    background: var(--surface);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 5px 8px 5px 4px;
    cursor: grab;
    user-select: none;
    pointer-events: auto;
    touch-action: none;
    transform: translateZ(0);
    will-change: transform;
    isolation: isolate;
    transition: background 0.35s ease, border-color 0.35s ease;
    box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    position: fixed;
    top: clamp(14px, 2vh, 24px);
    right: clamp(16px, 3.5vw, 44px);
    z-index: var(--z-ui);
}
.mode-cluster:active { cursor: grabbing; }
.mode-drag-handle {
    font-family: sans-serif;
    color: var(--ink-3);
    font-size: 12px;
    line-height: 1;
    padding-right: 6px;
    border-right: 1px solid var(--border);
    opacity: 0.4;
    display: flex;
    align-items: center;
    align-self: stretch;
    letter-spacing: -3px;
    margin-right: 2px;
    flex-shrink: 0;
}
.mode-key {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    width: 42px;
    height: 42px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s ease;
    padding: 0;
    position: relative;
    flex-shrink: 0;
}
.mode-key:hover {
    background: var(--hover-tint);
    border-color: var(--accent);
}
.mode-key:active { transform: scale(0.88); }
.mode-key-label {
    font-family: var(--ui-font);
    font-size: 10px;
    font-weight: 700;
    color: var(--ink);
    line-height: 1;
    letter-spacing: 0.02em;
}
.mode-key-desc {
    font-family: var(--ui-font);
    font-size: 7.5px;
    color: var(--ink-3);
    line-height: 1;
    letter-spacing: 0.05em;
    text-transform: uppercase;
}
.mode-key:hover .mode-key-label { color: var(--accent); }
.mode-key:hover .mode-key-desc { color: var(--accent); opacity: 0.7; }

/* Active state per mode */
.mode-key.mode-active {
    background: var(--hover-tint-strong);
    border-color: var(--accent);
}
.mode-key.mode-active .mode-key-label,
.mode-key.mode-active .mode-key-desc { color: var(--accent); }

/* Suppress old header-right styles — widget is now standalone */
.header-right { display: none; }

@media (max-width: 768px) {
    .mode-cluster {
        padding: 4px 6px;
        gap: 3px;
        cursor: default;
        top: clamp(10px, 1.5vh, 18px);
        right: clamp(12px, 3vw, 20px);
    }
    .mode-drag-handle { display: none; }
    .mode-key#modeKeyF,
    .mode-key#modeKeyC,
    .mode-key#modeKeySpace { display: none; }
    .mode-key {
        width: 38px;
        height: 38px;
    }
}

/* ===================================
   STATS WIDGET (+ MOBILE HUD)
   =================================== */
@keyframes hudEntrance {
    0%   { opacity: 0; transform: translateY(20px) scale(0.95); }
    60%  { opacity: 1; transform: translateY(-4px) scale(1.01); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes statPulse {
    0%   { transform: translateZ(0) scale(1); }
    40%  { transform: translateZ(0) scale(1.35); opacity: 1; }
    100% { transform: translateZ(0) scale(1); }
}

.stats-widget {
    position: fixed;
    bottom: 20px;
    left: 80px;
    z-index: var(--z-ui);
    display: flex;
    align-items: center;
    gap: 0;
    background: var(--surface);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 4px 2px 4px 4px;
    cursor: grab;
    user-select: none;
    transition: background 0.35s ease, border-color 0.35s ease;
    box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    touch-action: none;
    transform: translateZ(0);
    will-change: transform;
    isolation: isolate;
}
.stats-widget:active { cursor: grabbing; }

.stats-drag-handle {
    font-family: sans-serif;
    color: var(--ink-3);
    font-size: 12px;
    line-height: 1;
    padding-right: 6px;
    border-right: 1px solid var(--border);
    opacity: 0.4;
    display: flex;
    align-items: center;
    align-self: stretch;
    letter-spacing: -3px;
    margin-right: 0;
}
.stats-group { display: flex; align-items: center; }
.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 3px 9px;
    gap: 2px;
    border-right: 1px solid var(--border);
    min-width: 48px;
}
.stat-item:last-child { border-right: none; }
.stat-value {
    font-family: var(--ui-font);
    font-size: 13px;
    font-weight: 700;
    color: var(--accent);
    line-height: 1;
    transition: color 0.2s ease;
    display: inline-block;
    will-change: transform;
    transform: translateZ(0);
}
.stat-label {
    font-family: var(--ui-font);
    font-size: 7px;
    color: var(--ink-3);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    line-height: 1;
    white-space: nowrap;
}
.stat-value.pulse { animation: statPulse 0.35s ease-out; }

/* ── HUD nav buttons (hidden on desktop, shown on mobile) ── */
.hud-nav-btn {
    display: none;
    width: 40px;
    height: 40px;
    border-radius: 6px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    color: var(--accent);
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background 0.15s, transform 0.1s;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    flex-shrink: 0;
}
.hud-nav-btn svg { width: 18px; height: 18px; fill: currentColor; pointer-events: none; }
.hud-nav-btn:active { transform: scale(0.86); background: var(--hover-tint-strong); }
.hud-nav-btn.active-press { background: var(--accent) !important; color: var(--bg-color) !important; }

/* ── Mobile overrides ── */
@media (max-width: 768px) {
    .stats-widget {
        bottom: calc(16px + env(safe-area-inset-bottom));
        left: 0 !important;
        right: 0 !important;
        transform: none !important;
        margin-left: auto !important;
        margin-right: auto !important;
        width: fit-content !important;
        cursor: default;
        max-width: calc(100vw - 32px);
        width: auto;
        touch-action: none;
        padding: 5px 5px 5px 8px;
        border-radius: 12px;
        gap: 0;
        box-shadow: 0 4px 24px rgba(0,0,0,0.5);
        animation: hudEntrance 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s both;
    }
    .stats-widget:active { cursor: default; }
    .stats-drag-handle { display: none; }
    .hud-nav-btn { display: flex; }
    .stat-item { padding: 3px 7px; min-width: 44px; }
    .stat-value { font-size: 13px; }
    .stat-label { font-size: 6px; letter-spacing: 0.07em; }

    .hud-divider {
        width: 1px;
        align-self: stretch;
        background: var(--border);
        margin: 4px 3px;
        flex-shrink: 0;
    }
}



/* ===================================
   NAVIGATION RAILS
   =================================== */
.scroll-progress { 
    position: fixed; right: 24px; top: 50%; transform: translateY(-50%); 
    display: flex; flex-direction: column; align-items: center; gap: 12px; 
    z-index: var(--z-ui); pointer-events: auto; 
}
.chapter-progress-container { 
    display: flex; flex-direction: column; gap: 5px; padding: 8px 0; align-items: center;
}
.chapter-bar { 
    width: 16px; height: 3px; background: var(--chapter-bar-bg); border-radius: 2px; 
    cursor: pointer; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); position: relative;
}
.chapter-bar:hover { width: 24px; height: 24px; background: var(--chapter-bar-hover-bg); }
.chapter-bar.active { background: var(--accent); box-shadow: 0 0 6px rgba(218,165,32,0.5); }
.chapter-bar.active:hover { background: var(--accent); }
.chapter-bar.completed { background: var(--chapter-bar-completed-bg); }
.chapter-bar.completed:hover { background: var(--chapter-bar-completed-hover-bg); }
.chapter-bar::after {
    content: attr(data-chapter-title);
    position: absolute; right: calc(100% + 10px); top: 50%; transform: translateY(-50%);
    font-family: var(--ui-font); font-size: 10px; color: var(--ink-2);
    white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.15s ease;
    background: var(--surface-raised); padding: 3px 7px; border-radius: 3px;
    border: 1px solid var(--border); letter-spacing: 0.04em;
}
.chapter-bar:hover::after { opacity: 1; }
.nav-button { 
    width: 32px; height: 32px; border-radius: 50%; 
    background: var(--surface); border: 1px solid var(--border); 
    color: var(--ink-3); cursor: pointer; transition: all 0.15s ease; 
    display: flex; align-items: center; justify-content: center; font-size: 12px; 
    pointer-events: auto; user-select: none; -webkit-user-select: none; 
    -webkit-tap-highlight-color: transparent; touch-action: manipulation; 
}
.nav-button:hover { background: var(--hover-tint); border-color: var(--accent); color: var(--accent); transform: scale(1.08); }
.nav-button:active { transform: scale(0.94); }
.nav-button svg { width: 14px; height: 14px; fill: currentColor; }
.nav-button.active-press, .mobile-nav-button.active-press {
    background: var(--accent) !important; color: var(--bg) !important;
    transform: scale(0.94); transition: transform 0.1s ease;
}
.left-rail { 
    position: fixed; left: 0; top: 50%; transform: translateY(-50%); 
    z-index: var(--z-rail); padding: 16px 10px 16px 0; pointer-events: auto; display: flex; align-items: center; 
}
.lens-control-container { 
    background: var(--surface); border: 1px solid var(--border); 
    border-left: none; border-radius: 0 6px 6px 0; padding: 12px 6px; 
    display: flex; flex-direction: column; align-items: center; gap: 10px; backdrop-filter: blur(12px); 
    transition: background 0.35s ease, border-color 0.35s ease;
}
.lens-label { 
    font-family: var(--ui-font); font-size: 8px; color: var(--ink-3); 
    text-transform: uppercase; letter-spacing: 0.06em; writing-mode: vertical-rl; 
    text-orientation: mixed; transform: rotate(180deg); opacity: 0.6;
}
.accessibility-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; }
.accessibility-btn { 
    width: 24px; height: 24px; border-radius: 3px; background: rgba(255,255,255,0.04); 
    border: 1px solid var(--border); color: var(--ink-3); cursor: pointer; 
    display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; 
}
.accessibility-btn:hover { background: var(--hover-tint-strong); border-color: var(--accent); color: var(--accent); }
.accessibility-btn:active { transform: scale(0.9); }
.accessibility-btn svg { width: 14px; height: 14px; }
.accessibility-level { display: flex; flex-direction: column; gap: 3px; padding: 6px 0; }
.level-indicator { width: 14px; height: 2px; background: var(--border); border-radius: 1px; transition: background 0.2s ease; }
.level-indicator.active { background: var(--accent); }

/* ===================================
   MOBILE RAILS
   =================================== */
.mobile-right-rail { 
    display: none; position: fixed; right: 0; top: 0; bottom: 0; width: 60px; 
    background: var(--surface); backdrop-filter: blur(10px); z-index: var(--z-ui); 
    flex-direction: column; align-items: center; justify-content: center; gap: 20px; 
    border-left: 1px solid var(--border); padding: 20px 0; 
    transition: background 0.35s ease, border-color 0.35s ease;
}
.mobile-nav-container { 
    display: flex; justify-content: space-between; align-items: center; gap: 12px; 
    max-width: 500px; margin: 0 auto; width: 100%; 
}
.mobile-right-rail .mobile-nav-container { flex-direction: column; height: 100%; justify-content: space-between; }
.mobile-right-rail .rail-top-group, .mobile-right-rail .rail-bottom-group { display: flex; flex-direction: column; gap: 10px; align-items: center; }
.mobile-nav-group { display: flex; flex-direction: column; align-items: center; gap: 4px; }
.mobile-nav-button { 
    width: 48px; height: 48px; border-radius: 12px; background: var(--border); 
    border: 1px solid var(--border-strong); color: var(--accent); cursor: pointer; 
    transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; 
    pointer-events: auto; -webkit-tap-highlight-color: transparent; user-select: none; 
    -webkit-user-select: none; touch-action: manipulation; 
}
.mobile-nav-button:active { transform: scale(0.92); background: var(--hover-tint-strong); }
.mobile-nav-button svg { width: 22px; height: 22px; fill: currentColor; }
.mobile-nav-label { font-family: var(--ui-font); font-size: 9px; color: var(--ink-3); text-transform: uppercase; letter-spacing: 0.05em; }
.mobile-progress-container { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 6px; padding: 0 12px; }
.mobile-right-rail .mobile-progress-container { height: 100%; width: 100%; flex: 1; justify-content: center; padding: 20px 0; }
.mobile-right-rail .mobile-progress-bar { width: 4px; height: 100%; max-height: 200px; }
.mobile-right-rail .mobile-progress-fill { width: 100%; height: 0%; bottom: 0; top: auto; transition: height 0.3s ease; }
.mobile-progress-text { font-family: var(--ui-font); font-size: 10px; color: var(--ink-2); letter-spacing: 0.05em; }
.mobile-progress-bar { width: 100%; height: 4px; background: var(--border-strong); border-radius: 2px; position: relative; overflow: hidden; }
.mobile-progress-fill { position: absolute; left: 0; top: 0; height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s ease; width: 0%; }

body.image-active .sentence:not(.active) { opacity: 0.1; color: var(--ink-3); }
body.image-active .sentence.active { opacity: 1; color: var(--sentence-active-color); }
body.image-active .sentence.dimmed { opacity: 0.01; color: var(--ink-3); }

/* ===================================
   ACCESSIBILITY
   =================================== */
.sr-only {
    position: absolute;
    width: 1px; height: 1px;
    padding: 0; margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border: 0;
}
.skip-link {
    position: fixed;
    top: -100%;
    left: 16px;
    z-index: 99999;
    background: var(--accent);
    color: var(--bg-color);
    font-family: var(--ui-font);
    font-size: 12px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 8px 16px;
    border-radius: 3px;
    text-decoration: none;
    transition: top 0.15s ease;
    outline: none;
}
.skip-link:focus { top: 16px; }

/* Focus visible ring — all interactive elements */
:focus { outline: none; }
:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
    border-radius: 2px;
}
/* Sentence focus ring — ONLY when navigating by Tab, not arrow keys / scroll / spacebar */
body:not([data-tab-nav]) .sentence:focus-visible { outline: none; }
body[data-tab-nav] .sentence:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 3px;
    border-radius: 2px;
}
/* Image triggers keyboard focus */
.image-trigger:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
    border-radius: 1px;
    color: var(--accent);
}
/* Bracket triggers */
.bracket-trigger:focus-visible {
    outline: 2px solid var(--bracket-hover);
    outline-offset: 2px;
    border-radius: 1px;
}

/* ===================================
   BASE STYLES
   =================================== */
*, *::before, *::after { box-sizing: border-box; }
html { color-scheme: dark; -webkit-text-size-adjust: 100%; }
body, html { height: 100%; margin: 0; overflow-x: hidden; }
body { 
    background: var(--bg-color); color: var(--ink); font: 18px/1.8 var(--body-font); 
    overflow: hidden; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; 
    -webkit-tap-highlight-color: transparent; cursor: none; user-select: none; 
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
    transition: background-color 0.35s ease, color 0.35s ease;
}
body::-webkit-scrollbar { display: none; }
body { -ms-overflow-style: none; scrollbar-width: none; }
::selection { background: var(--selection-bg); color: var(--selection-color); }

/* ===================================
   FLOW MODE
   =================================== */
body.flow-mode .sentence { opacity: 0.15; transition: opacity 0.6s ease; }
body.flow-mode .sentence.active { opacity: 1; }
body.flow-mode .sentence.revealed { opacity: 0.6; }
body.flow-mode .text-layer { overflow-y: auto; height: 100vh; -webkit-overflow-scrolling: touch; }
/* Nuanced Split View trigger: allows text to fade when an image is active */
body.layout-split.image-active .sentence:not(.active) { 
    opacity: 0.25; 
    color: var(--ink-3); 
    transition: opacity 0.4s ease;
}

/* ===================================
   INTERACTION HINTS
   =================================== */
.interaction-hint { 
    position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%); z-index: 9998; 
    font-family: var(--ui-font); font-size: 11px; letter-spacing: 0.1em; 
    text-transform: uppercase; color: var(--accent); opacity: 0; 
    animation: hintPulse 3s ease-in-out; pointer-events: none; 
}
@keyframes hintPulse { 0%, 100% { opacity: 0; } 10%, 90% { opacity: 0.6; } 50% { opacity: 0.3; } }
body.hint-shown .interaction-hint { display: none; }

/* ===================================
   CONTEXT MENU
   =================================== */


/* ===================================
   VISUAL EFFECTS
   =================================== */
.edge-blur { 
    position: fixed; inset: 0; pointer-events: none; z-index: var(--z-blur); 
    backdrop-filter: blur(var(--edge-blur)); -webkit-backdrop-filter: blur(var(--edge-blur)); 
    mask: radial-gradient(100% 64% at 50% 50%, transparent var(--edge-mask-i), rgb(255 255 255 / 0.98) var(--edge-mask-o)); 
    -webkit-mask: radial-gradient(100% 64% at 50% 50%, transparent var(--edge-mask-i), rgb(255 255 255 / 0.98) var(--edge-mask-o));
    transform: translateZ(0);
    will-change: transform;
}
.vignette { 
    position: fixed; inset: 0; pointer-events: none; z-index: var(--z-vig); 
    background: radial-gradient(120% 90% at 50% 50%, #fff0 var(--vig-inner), rgb(0 0 0 / 0.55) var(--vig-mid), rgb(0 0 0 / 0.9) var(--vig-outer)); 
    opacity: calc(var(--vig-opacity) * var(--curve-k));
    transform: translateZ(0);
    will-change: opacity;
    transition: opacity 0.35s ease;
}
body::after { 
    content: ""; position: fixed; inset: 0; pointer-events: none; z-index: var(--z-grain); opacity: 0.08; 
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.45'/%3E%3C/svg%3E"); 
    background-size: 120px 120px;
    transform: translateZ(0);
    will-change: transform;
    transition: opacity 0.35s ease;
}
body.theme-transitioning::after {
    opacity: 0;
}

/* ===================================
   PARALLAX & LAYERS
   =================================== */
.curved { 
    position: fixed; inset: 0; transform-style: preserve-3d; 
    transform: perspective(1000px) translateZ(calc(-200px * var(--curve-k))) scale(calc(1 + var(--curve-k) * 0.06)); 
    will-change: transform; z-index: var(--z-content);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
.parallax-container { position: relative; width: 100%; height: 100%; overflow: hidden; }
.text-layer { 
    position: relative; z-index: 10; padding: 15vh 8vw 25vh; max-width: 99%; margin: 0 auto; 
    transform-style: preserve-3d; will-change: transform; transition: transform 0.1s linear;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
.image-layer { 
    position: fixed; inset: 0; z-index: 5; pointer-events: none; 
    transform-style: preserve-3d; will-change: transform; transition: transform 0.1s linear;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
.stream { font-size: clamp(18px, 2.5vw, 32px); line-height: var(--stream-line-height); letter-spacing: var(--stream-letter-spacing); max-width: 100%; color: var(--sentence-color); font-family: var(--body-font); transition: color 0.35s ease, font-family 0.1s; }
.sentence { display: inline; transition: opacity 0.3s ease, color 0.3s ease, background 0.3s ease; cursor: none; position: relative; z-index: 2; letter-spacing: -0.01em; }
.sentence.active { color: var(--sentence-active-color); opacity: 1; text-shadow: var(--sentence-active-shadow); background: var(--sentence-active-bg); padding: 2px 6px; border-radius: 2px; }
.sentence.dimmed { opacity: var(--sentence-dimmed-opacity); color: var(--sentence-dimmed-color); }
.bullet-item, .numbered-bullet-item { display: block; margin: 0.5em 0; padding-left: 1.5em; position: relative; }
.bullet-marker, .numbered-marker { position: absolute; left: 0; color: var(--accent); font-weight: 600; }
.bullet-marker { font-size: 1.2em; line-height: 1.5; }
.numbered-marker { font-family: var(--ui-font); font-size: 0.85em; }
.line-break-spacer { display: inline; pointer-events: none; background: none !important; padding: 0 !important; }

/* ===================================
   CHAPTER BREAKS
   =================================== */
.chapter-break { 
    display: block; margin: 3em 0 2em; padding: 1.5em 0; 
    border-top: var(--chapter-break-border-width) solid color-mix(in srgb, var(--accent) 30%, transparent); 
    border-bottom: var(--chapter-break-border-width) solid color-mix(in srgb, var(--accent) 30%, transparent); 
    text-align: center; font-family: var(--ui-font); font-size: var(--chapter-break-font-size); 
    letter-spacing: var(--chapter-break-letter-spacing); 
    text-transform: uppercase; color: var(--accent); opacity: 0.7; cursor: pointer; transition: all 0.3s ease; pointer-events: auto; 
}
.chapter-break:hover { opacity: 1; background: var(--hover-tint); padding: 1.5em 1em; }
.chapter-break.dropdown-active { opacity: 1; background: var(--hover-tint-strong); border-color: color-mix(in srgb, var(--accent) 60%, transparent); color: var(--accent); }
.chapter-break .chapter-number { display: block; font-size: 0.7em; margin-bottom: 0.5em; color: var(--ink-3); }
.chapter-break .chapter-title { display: block; font-size: 1.2em; font-weight: var(--chapter-break-weight); letter-spacing: var(--chapter-break-letter-spacing); }

/* ===================================
   SUBCHAPTER BREAKS
   =================================== */
.subchapter-break {
    display: block; margin: 2em 0 1.5em; padding: 0.75em 0;
    border-top: 1px solid color-mix(in srgb, var(--accent) 15%, transparent);
    text-align: center; font-family: var(--ui-font); font-size: var(--chapter-break-font-size);
    letter-spacing: var(--chapter-break-letter-spacing);
    text-transform: uppercase; color: var(--ink-3); opacity: 0.5;
    pointer-events: none; transition: opacity 0.3s ease;
}
.subchapter-break .subchapter-title {
    display: inline-block; font-size: 1.11em;
    font-weight: var(--chapter-break-weight);
    letter-spacing: var(--chapter-break-letter-spacing);
}

/* ===================================
   PULL-QUOTE BREAKS (>>: syntax)
   Voice interjections — e.g. Wolfie speaking
   =================================== */
.pullquote-break {
    display: block;
    margin: 2.5em 0 2em;
    padding: 1.4em 1.8em 0.6em 1.6em;
    position: relative;
    border-left: 1px solid var(--accent);
    background: linear-gradient(135deg,
        color-mix(in srgb, var(--accent) 3%, transparent),
        color-mix(in srgb, var(--accent) 1%, transparent));
    border-radius: 0 6px 6px 0;
    pointer-events: none;
    transition: border-color 0.3s ease, background 0.3s ease;
    overflow: hidden;
}
.pullquote-break::before {
    content: '\201C';
    position: absolute;
    top: -0.1em;
    left: 0.3em;
    font-family: var(--body-font);
    font-size: 4em;
    color: var(--accent);
    opacity: 0.18;
    line-height: 1;
    pointer-events: none;
    user-select: none;
}
.pullquote-voice {
    display: block;
    font-family: var(--ui-font);
    font-size: var(--chapter-break-font-size);
    letter-spacing: var(--chapter-break-letter-spacing);
    text-transform: uppercase;
    color: var(--accent);
    opacity: 0.7;
    margin-bottom: 0.6em;
    font-weight: var(--chapter-break-weight);
}
.pullquote-text {
    display: block;
    font-family: var(--body-font);
    font-size: clamp(15px, 1.8vw, 22px);
    font-style: italic;
    color: var(--ink-2);
    line-height: 1.6;
    letter-spacing: 0.01em;
}

/* Compose mode: treat like other structural blocks */
body.compose-mode .pullquote-break {
    display: flex;
    align-items: baseline;
    padding: 4px 0;
    border-left: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    background: none;
    border-radius: 0;
    position: relative;
}
body.compose-mode .pullquote-break::before { display: none; }
body.compose-mode .pullquote-break:last-child { border-bottom: none; }
body.compose-mode .pullquote-break.drag-over-above { box-shadow: inset 0 2px 0 0 var(--accent); }
body.compose-mode .pullquote-break.drag-over-below { box-shadow: inset 0 -2px 0 0 var(--accent); }
body.compose-mode .pullquote-break.dragging { opacity: 0.35; }
body.compose-mode .pullquote-break:hover .sentence-drag-handle { opacity: 0.4; }
body.compose-mode .pullquote-break .sentence-drag-handle { display: flex; align-items: center; justify-content: center; }

/* ===================================
   PAGE LOADER
   =================================== */
#pageLoader {
    position: fixed;
    inset: 0;
    z-index: 99999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
    pointer-events: all;
    transition: opacity 0.6s ease;
}
#pageLoader.fade-out {
    opacity: 0;
    pointer-events: none;
}
#pageLoader video {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.55;
}
.loader-overlay {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 18px;
    pointer-events: none;
    user-select: none;
}
.loader-paw {
    font-size: 40px;
    animation: loaderPawPulse 1.4s ease-in-out infinite;
}
@keyframes loaderPawPulse {
    0%, 100% { transform: scale(1); opacity: 0.9; }
    50% { transform: scale(1.18); opacity: 1; }
}
.loader-wordmark {
    font-family: var(--ui-font);
    font-size: 11px;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    color: var(--accent);
    opacity: 0.9;
}
.loader-bar-track {
    width: 120px;
    height: 2px;
    background: rgba(255,255,255,0.12);
    border-radius: 2px;
    overflow: hidden;
}
.loader-bar-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    width: 0%;
    animation: loaderBarSweep 1.8s ease-in-out forwards;
}
@keyframes loaderBarSweep {
    0%   { width: 0%; }
    60%  { width: 75%; }
    85%  { width: 90%; }
    100% { width: 100%; }
}

/* ===================================
   BRACKETS
   =================================== */
.bracket-trigger { 
    all: unset; cursor: none; font-family: var(--ui-font); font-size: 0.65em; 
    color: var(--bracket-color); letter-spacing: 0.02em; transition: all 0.2s ease; 
    border-bottom: 1px dotted var(--bracket-color); padding-bottom: 1px; 
    display: inline; vertical-align: baseline; line-height: inherit; margin: 0 0.1em; 
}
.bracket-trigger:hover { color: var(--bracket-hover); opacity: 1; border-bottom-color: var(--bracket-hover); }
.bracket-trigger.expanded { opacity: 0.5; }
.bracket-content { 
    display: none; font-size: 0.8em; color: var(--ink-2); font-style: italic; 
    line-height: inherit; padding-left: 0.2em; margin-left: 0.2em; 
    border-left: 1px solid color-mix(in srgb, var(--accent) 50%, transparent); padding-right: 0.2em; 
    background: var(--bracket-bg); animation: bracketFadeIn 0.3s ease-out; 
}
.bracket-content.visible { display: inline; }
@keyframes bracketFadeIn { from { opacity: 0; transform: translateY(-4px); } to { opacity: 1; transform: translateY(0); } }

/* ===================================
   IMAGE TRIGGERS & HOVER
   =================================== */
.image-trigger {
    all: unset;
    position: relative;
    text-decoration: none;
    border-bottom: 1px dotted var(--accent);
    cursor: help;
    transition: all 0.2s ease;
    opacity: 0.9;
    display: inline;
    font: inherit;
    color: inherit;
    letter-spacing: inherit;
    line-height: inherit;
}
.image-trigger:hover { color: var(--accent); border-bottom-style: solid; opacity: 1; }
.hover-image { 
    position: absolute; z-index: 1; pointer-events: none; opacity: 0; 
    transition: opacity 0.4s cubic-bezier(0.25, 1, 0.5, 1), transform 0.1s linear; 
    width: 1400px; height: 1050px; border-radius: 8px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4); 
    transform: translate(-50%, -50%) scale(0.95); filter: brightness(0.9) contrast(1.05); 
    will-change: transform, opacity; left: 50%; top: 50%; 
}
.hover-image.active { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
.hover-image img, .hover-image video { display: block; width: 100%; height: 100%; object-fit: cover; border-radius: 8px; }
.hover-image img { display: block; }
.hover-image video { display: none; }

/* ===================================
   HEADER
   =================================== */
.header { 
    position: fixed; top: 0; left: 0; right: 0; z-index: var(--z-ui); 
    padding: clamp(14px, 2vh, 24px) clamp(16px, 3.5vw, 44px); 
    display: flex; justify-content: space-between; align-items: center; pointer-events: none; 
}
.brand-container { position: relative; pointer-events: auto; }
.header-right { display: flex; align-items: center; gap: 8px; pointer-events: auto; }
.brand { 
    font-family: var(--ui-font); font-size: 10px; letter-spacing: 0.1em; 
    text-transform: uppercase; color: var(--ink-3); padding: 5px 9px; border-radius: 3px; 
    transition: all 0.25s ease; text-decoration: none; background: var(--surface); 
    border: 1px solid var(--border); cursor: pointer; 
    display: flex; align-items: center; gap: 7px; 
}
.brand:hover { background: var(--hover-tint); color: var(--ink); border-color: var(--accent); }
.brand:active { transform: scale(0.95); }
.brand-dropdown-icon { font-size: 9px; transition: transform 0.2s ease; opacity: 0.6; }
.brand.open .brand-dropdown-icon { transform: rotate(180deg); opacity: 1; }

/* ===================================
   CHAPTER DROPDOWN — DRAGGABLE
   =================================== */
.chapter-dropdown { 
    position: fixed;
    top: 52px;
    left: clamp(16px, 3.5vw, 44px);
    min-width: 260px; 
    background: var(--surface-raised); 
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); 
    border: 1px solid var(--border); border-radius: 6px; padding: 6px 0; 
    opacity: 0; visibility: hidden;
    transition: opacity 0.2s cubic-bezier(0.25, 1, 0.5, 1), visibility 0.2s; 
    z-index: var(--z-dropdown); box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5); 
    max-height: 70vh; display: flex; flex-direction: column; 
    touch-action: none;
    transform: none;
}
.chapter-dropdown.open { opacity: 1; visibility: visible; }
.chapter-dropdown.dragging { 
    transition: none !important; 
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
    border-color: var(--accent);
}
.chapter-dropdown-header { 
    padding: 9px 14px; border-bottom: 1px solid var(--border); 
    margin-bottom: 4px; flex-shrink: 0;
    display: flex; align-items: center; gap: 7px;
    cursor: grab;
    user-select: none;
}
.chapter-dropdown-header:active { cursor: grabbing; }
.dropdown-drag-handle {
    font-family: sans-serif;
    color: var(--ink-3);
    font-size: 12px;
    letter-spacing: -2px;
    opacity: 0.35;
    line-height: 1;
    flex-shrink: 0;
}
.chapter-dropdown-header h3 { 
    font-family: var(--ui-font); font-size: 9px; letter-spacing: 0.12em; 
    text-transform: uppercase; color: var(--ink-3); margin: 0; font-weight: 400; flex: 1;
}
.chapter-dropdown-list { 
    overflow-y: auto; padding: 0; margin: 0; list-style: none; 
    overscroll-behavior: contain; -webkit-overflow-scrolling: touch; 
}
.chapter-dropdown-list::-webkit-scrollbar { width: 3px; }
.chapter-dropdown-list::-webkit-scrollbar-track { background: transparent; }
.chapter-dropdown-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.chapter-item { padding: 8px 14px; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 10px; }
.chapter-item:hover { background: var(--hover-tint); }
.chapter-item.active { background: var(--hover-tint-strong); border-left: 2px solid var(--accent); padding-left: 12px; }
.chapter-item-number { font-family: var(--ui-font); font-size: 9px; color: var(--ink-3); min-width: 36px; letter-spacing: 0.04em; }
.chapter-item-title { font-family: var(--body-font); font-size: 13px; color: var(--ink-2); font-style: italic; }
.chapter-item.active .chapter-item-title { color: var(--accent); font-style: normal; }
.chapter-item-progress { margin-left: auto; font-family: var(--ui-font); font-size: 8px; color: var(--ink-3); background: rgba(255,255,255,0.04); padding: 2px 5px; border-radius: 2px; }

/* ===================================
   HEADER BUTTONS
   =================================== */
.preview-toggle, .layout-toggle, .theme-toggle { pointer-events: auto; }
.preview-button, .layout-button, .grid-toggle-btn, .theme-button { 
    background: var(--surface); border: 1px solid var(--border); 
    padding: 5px 10px; border-radius: 3px; cursor: pointer; transition: all 0.25s ease; 
    display: flex; align-items: center; justify-content: center; 
    font-family: var(--ui-font); font-size: 9px; color: var(--ink-3); gap: 5px; pointer-events: auto; 
    letter-spacing: 0.06em;
}
.preview-button:hover, .layout-button:hover, .grid-toggle-btn:hover, .theme-button:hover { background: var(--hover-tint); border-color: var(--accent); color: var(--ink); }
.preview-button:active, .layout-button:active, .grid-toggle-btn:active, .theme-button:active { transform: scale(0.95); }
.preview-button.active { border-color: var(--accent); color: var(--accent); }
.layout-icon { width: 24px; height: 20px; position: relative; display: flex; flex-direction: column; justify-content: space-between; }
.layout-icon.layered::before, .layout-icon.layered::after { content: ''; display: block; width: 100%; height: 6px; background: var(--ink-3); border-radius: 1px; transition: all 0.3s ease; }
.layout-icon.layered::after { opacity: 0.5; margin-top: -4px; }
.layout-icon.split::before, .layout-icon.split::after { content: ''; display: block; border-radius: 1px; transition: all 0.3s ease; }
.layout-icon.split::before { width: 10px; height: 100%; background: var(--ink-3); }
.layout-icon.split::after { width: 10px; height: 100%; background: var(--ink-3); margin-left: 4px; opacity: 0.5; }
.grid-toggle-btn { text-transform: uppercase; letter-spacing: 0.05em; }

/* New SVG layout icon styles */
.layout-icon-landscape, .layout-icon-portrait { stroke: var(--ink-3); transition: all 0.3s ease; }
body.layout-layered .layout-icon-landscape { display: block; }
body.layout-layered .layout-icon-portrait { display: none; }
body.layout-split .layout-icon-landscape { display: none; }
body.layout-split .layout-icon-portrait { display: block; }

/* ===================================
   IMAGE GRID OVERLAY
   =================================== */
.image-grid-overlay { 
    position: fixed; inset: 0; z-index: var(--z-overlay); background: var(--grid-overlay-bg); 
    backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); 
    display: none; flex-direction: column; opacity: 0; transition: opacity 0.3s ease; overflow-y: auto; 
}
.image-grid-overlay.open { display: flex; opacity: 1; }
.close-hotspot { 
    position: fixed; top: 0; right: 0; width: 25vw; height: 25vh; min-width: 150px; min-height: 150px; 
    z-index: calc(var(--z-overlay) + 10); cursor: none; display: none; pointer-events: auto; 
}
.grid-close-hotspot { z-index: calc(var(--z-overlay) + 10); display: none; }
body.grid-open .grid-close-hotspot { display: block; }
.split-close-hotspot { z-index: calc(var(--z-ui) + 10); display: none !important; }
.rotate-close-hotspot { z-index: calc(var(--z-rotate-warning) + 1); display: none; }
@media (orientation: portrait) { body.layout-split .rotate-close-hotspot { display: block; } }
#cursor.close-mode { width: 60px; height: 60px; border-color: var(--accent); background: var(--hover-tint-strong); }
#cursor.close-mode::before { content: '✕'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; font-weight: bold; color: var(--accent); line-height: 1; }
/* ── Grid Chrome: Wireframe Background ── */
.grid-wireframe-bg {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    opacity: 0;
    transition: opacity 0.4s ease;
    background-image:
        linear-gradient(var(--border) 1px, transparent 1px),
        linear-gradient(90deg, var(--border) 1px, transparent 1px);
    background-size: 48px 48px;
    will-change: transform;
}
.grid-wireframe-bg.visible { opacity: 1; }

/* ── Grid Chrome: Layout ── */
.grid-content { 
    padding: 80px 0 0 0; 
    width: 100%; 
    will-change: transform; 
    transition: transform 0.1s linear;
    position: relative;
    z-index: 1;
}
.grid-chapter-section { margin-bottom: 0; }
.grid-chapter-title { 
    font-family: var(--ui-font); 
    font-size: 10px; 
    color: var(--accent); 
    text-transform: uppercase; 
    letter-spacing: 0.15em; 
    padding: 10px 20px; 
    border-bottom: 1px solid var(--border);
    border-top: 1px solid var(--border);
    opacity: 0.6;
    background: rgba(255,255,255,0.01);
}
/* ── Continuous Chrome Grid ── */
.grid-images-container { 
    display: grid; 
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); 
    gap: 0;
    border-left: 1px solid var(--border);
    border-top: 1px solid var(--border);
}

/* ── Grid Item: Flat Chrome Cell ── */
.grid-image-item { 
    position: relative; 
    aspect-ratio: 4/3; 
    overflow: hidden; 
    cursor: pointer; 
    border-right: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    transition: background 0.2s ease; 
    background: transparent;
}
.grid-image-item:hover { background: rgba(255,255,255,0.02); }
.grid-image-item img, .grid-image-item video { 
    width: 100%; height: 100%; object-fit: cover; opacity: 0.85; 
    transition: opacity 0.25s ease; display: block;
}
.grid-image-item:hover img,
.grid-image-item:hover video { opacity: 0.45; filter: blur(1px); }

/* ── Inline Edit: Caption/Title fields ── */
.grid-image-caption { 
    position: absolute; inset: 0; 
    display: flex; flex-direction: column; align-items: center; justify-content: center; 
    padding: 16px; opacity: 0; transition: opacity 0.2s ease; 
}
.grid-image-item:hover .grid-image-caption { opacity: 1; }
.grid-inline-input {
    background: transparent;
    border: none;
    outline: none;
    color: #fff;
    font-family: var(--body-font);
    font-size: 15px;
    line-height: 1.4;
    text-align: center;
    width: 100%;
    resize: none;
    cursor: text;
    padding: 4px 6px;
    border-radius: 2px;
    transition: background 0.15s ease, border 0.15s ease;
    border: 1px solid transparent;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9);
}
.grid-inline-input:hover,
.grid-inline-input:focus {
    background: rgba(255,255,255,0.05);
    border-color: var(--accent);
    text-shadow: none;
}
.grid-inline-input::placeholder { color: rgba(255,255,255,0.3); font-size: 12px; }

/* ── Hover-Triggered Delete Button ── */
.grid-item-delete {
    position: absolute;
    top: 6px; right: 6px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s ease;
    background: rgba(0,0,0,0.7);
    border: 1px solid var(--border);
    color: var(--ink-3);
    font-family: var(--ui-font);
    font-size: 9px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    padding: 3px 7px;
    cursor: pointer;
    border-radius: 2px;
    z-index: 10;
}
.grid-item-delete:hover {
    background: rgba(200,50,50,0.25);
    border-color: rgba(220,80,80,0.5);
    color: #ff8080;
}
.grid-image-item:hover .grid-item-delete {
    opacity: 1;
    pointer-events: auto;
}

/* ===================================
   CUSTOM CURSOR
   =================================== */
#cursor { 
    position: fixed; top: 0; left: 0; width: 20px; height: 20px; 
    background: var(--cursor-bg);
    border: 1px solid var(--cursor-border); border-radius: 50%; pointer-events: none; z-index: 9999; 
    transform: translate3d(-50px, -50px, 0) translate(-50%, -50%); 
    transition: width 0.25s, height 0.25s, background-color 0.25s, border-color 0.25s, opacity 0.25s; 
    mix-blend-mode: var(--cursor-blend); will-change: transform;
    opacity: var(--cursor-opacity);
    overflow: hidden;
}
#cursor.hovering { width: 36px; height: 36px; background-color: var(--hover-tint); border-color: var(--accent); }
#cursor.pointer { width: 14px; height: 14px; background-color: var(--ink); }
#cursor.has-image { opacity: 0; }

/* Cursor thumbnail — letterbox, focus mode only */
#cursor-thumb {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    pointer-events: none;
    border-radius: 0;
    display: block;
    transition: opacity 0.2s ease;
}
#cursor.thumb-active {
    width: 220px;
    height: 130px;
    border-radius: 3px;
    border: 1px solid rgba(255,255,255,0.12);
    background: #000;
    mix-blend-mode: normal;
    opacity: 1;
    transition: width 0.2s cubic-bezier(0.25,1,0.5,1),
                height 0.2s cubic-bezier(0.25,1,0.5,1),
                border-radius 0.2s ease,
                opacity 0.15s ease;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6);
}
#cursor.thumb-active #cursor-thumb { opacity: 1; }

/* Suppress background image layer in focus mode — cursor IS the image */
body.focus-mode .hover-image { opacity: 0 !important; }

/* ===================================
   TOAST NOTIFICATIONS
   =================================== */
.toast-container {
    position: fixed;
    top: 64px;
    left: 50%;
    transform: translateX(-50%);
    z-index: calc(var(--z-ui) + 50);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    pointer-events: none;
}
.toast {
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--surface-raised);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 13px;
    font-family: var(--ui-font);
    font-size: 10px;
    color: var(--ink-2);
    letter-spacing: 0.04em;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    pointer-events: auto;
    cursor: pointer;
    opacity: 0;
    transform: translateY(-8px) scale(0.97);
    transition: opacity 0.25s cubic-bezier(0.25, 1, 0.5, 1),
                transform 0.25s cubic-bezier(0.25, 1, 0.5, 1);
    max-width: min(85vw, 340px);
    white-space: normal;
    text-align: center;
    line-height: 1.5;
}
.toast.visible {
    opacity: 1;
    transform: translateY(0) scale(1);
}
.toast.dismissing {
    opacity: 0;
    transform: translateY(-6px) scale(0.97);
}

/* Banner variant */
.toast.toast-banner {
    position: fixed;
    top: 96px;
    left: 50%;
    bottom: auto;
    transform: translateX(-50%) translateY(-12px) scale(0.97);
    max-width: min(92vw, 520px);
    text-align: center;
    justify-content: center;
    border-color: color-mix(in srgb, var(--accent) 30%, transparent);
    box-shadow: 0 8px 36px rgba(0,0,0,0.5);
    font-size: 11px;
    padding: 11px 18px;
    gap: 10px;
    border-radius: 4px;
}
.toast.toast-banner.visible {
    transform: translateX(-50%) translateY(0) scale(1);
}
.toast.toast-banner.dismissing {
    transform: translateX(-50%) translateY(-8px) scale(0.97);
}

.toast-icon {
    font-size: 12px;
    flex-shrink: 0;
    opacity: 0.7;
}
.toast-text { line-height: 1.5; }
.toast-accent { color: var(--accent); font-weight: 600; }
.toast-action {
    margin-left: 4px;
    padding: 2px 7px;
    border: 1px solid var(--accent);
    border-radius: 2px;
    color: var(--accent);
    font-size: 9px;
    cursor: pointer;
    transition: background 0.15s ease;
    flex-shrink: 0;
    pointer-events: auto;
    white-space: nowrap;
}
.toast-action:hover { background: var(--hover-tint-strong); }

/* Toast rail bell button */
.toast-rail-btn {
    position: relative;
    width: 28px;
    height: 28px;
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--ink-3);
    transition: color 0.2s ease;
    padding: 0;
}
.toast-rail-btn:hover { color: var(--accent); }
.toast-rail-btn svg { width: 18px; height: 18px; }
.toast-rail-dot {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}
.toast-rail-dot.active { opacity: 1; animation: dotPulse 2s ease-in-out infinite; }
@keyframes dotPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.4); opacity: 0.6; }
}

/* Chapter logo pulse on chapter crossing */
.brand.chapter-pulse {
    border-color: var(--accent) !important;
    color: var(--accent) !important;
    background: var(--hover-tint-strong) !important;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 25%, transparent);
    transition: all 0.2s ease !important;
}

@media (max-width: 768px) {
    .toast-container {
        top: 64px;
        bottom: auto;
    }
    .toast { text-align: center; }
}

/* ===================================
   ROTATE WARNING
   =================================== */
.rotate-warning { 
    position: fixed; inset: 0; z-index: var(--z-rotate-warning); 
    background: var(--bg-color); /* Theme aware background */
    backdrop-filter: blur(10px); 
    display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px; 
    color: var(--accent); 
}
.rotate-warning svg { width: 48px; height: 48px; fill: var(--accent); margin-bottom: 20px; animation: rotateIcon 2s infinite ease-in-out; }
.rotate-warning p { font-family: 'Space Mono', monospace; font-size: 14px; color: var(--ink); max-width: 300px; line-height: 1.6; }
@keyframes rotateIcon { 0% { transform: rotate(0deg); } 25% { transform: rotate(-90deg); } 75% { transform: rotate(-90deg); } 100% { transform: rotate(0deg); } }
@keyframes bounce { 0%, 100% { transform: rotate(45deg) translateY(0); } 50% { transform: rotate(45deg) translateY(8px); } }
@keyframes fadeInOut { 0%, 100% { opacity: 0; } 20%, 80% { opacity: 1; } }
@media (orientation: portrait) { body.layout-split .rotate-warning { display: flex; } }
.rotate-warning.visible { display: flex; }

/* ===================================
   RESPONSIVE BREAKPOINTS
   =================================== */
@media (max-height: 500px) and (orientation: landscape) {
    .scroll-progress { display: none; }
    .left-rail { display: flex; padding: 10px 4px 10px 0; }
    .mobile-nav-button { width: 36px; height: 36px; }
    .mobile-progress-text { font-size: 9px; }
    .text-layer { padding: 10vh 8vw 20vh; max-width: 90%; }
    .header { padding: 10px 20px; }
    .stream { font-size: clamp(16px, 3vw, 24px); }
    .preview-toggle { display: none; }
}

@media (max-width: 768px) {
    .scroll-progress { display: none; }
    .left-rail { display: flex; }
    .text-layer { padding: 12vh 6vw 20vh 50px; max-width: 95%; }
    .stream { font-size: clamp(16px, 4vw, 28px); }
    .hover-image { width: 800px; height: 600px; }
    .chapter-dropdown { min-width: 240px; }
    .grid-images-container { grid-template-columns: repeat(4, 1fr); gap: 0; }
    .grid-content { padding: 100px 10vw; }
    body.layout-split .text-layer { width: 100%; padding-left: 50px; padding-right: 20px; }
    body.layout-split .hover-image { position: absolute; left: 50%; top: 50%; width: 800px; height: 600px; transform: translate(-50%, -50%) scale(0.95); }
    @media (pointer: coarse) { #cursor { display: none !important; } }
    * { -webkit-tap-highlight-color: var(--hover-tint); }
    .nav-button { -webkit-tap-highlight-color: var(--hover-tint-strong); }
}

@media (prefers-reduced-motion: reduce) {
    .edge-blur { backdrop-filter: none; -webkit-backdrop-filter: none; }
    * { animation: none !important; transition: none !important; }
}

    /* ── UI fade-in on pageload ── */
    .header, .scroll-progress, .left-rail, #statsWidget, .mode-cluster, #keyboardLegend {
        transition: opacity 2.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.35s ease,
                    background 0.35s ease, border-color 0.35s ease;
    }
    body.ui-concealed .header, body.ui-concealed .scroll-progress, body.ui-concealed .left-rail,
    body.ui-concealed #statsWidget, body.ui-concealed .mode-cluster, body.ui-concealed #keyboardLegend {
        opacity: 0 !important; pointer-events: none !important;
    }

    /* H key: hide all UI chrome, leaving only the reading surface */
    body.ui-hidden .header,
    body.ui-hidden .scroll-progress,
    body.ui-hidden .left-rail,
    body.ui-hidden #keyboardLegend {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    /* statsWidget fades but nav buttons stay live in ui-hidden mode */
    body.ui-hidden #statsWidget {
        opacity: 0.08;
        transition: opacity 0.3s ease;
    }
    body.ui-hidden #statsWidget #hudPrevBtn,
    body.ui-hidden #statsWidget #hudNextBtn {
        opacity: 1;
        pointer-events: auto;
    }
    body:not(.ui-hidden) .header,
    body:not(.ui-hidden) .scroll-progress,
    body:not(.ui-hidden) .left-rail,
    body:not(.ui-hidden) #statsWidget,
    body:not(.ui-hidden) #keyboardLegend {
        transition: opacity 0.3s ease;
    }
    /* ui-hidden hotzone — top-right corner, matches existing close-hotspot geometry */
    .ui-hidden-hotspot {
        position: fixed;
        top: 0; right: 0;
        width: 25vw; height: 25vh;
        min-width: 150px; min-height: 150px;
        z-index: calc(var(--z-ui) + 5);
        cursor: none;
        display: none;
        pointer-events: auto;
    }
    body.ui-hidden .ui-hidden-hotspot { display: block; }

    /* focus-mode hotzone — same geometry */
    .focus-mode-hotspot {
        position: fixed;
        top: 0; right: 0;
        width: 25vw; height: 25vh;
        min-width: 150px; min-height: 150px;
        z-index: calc(var(--z-ui) + 5);
        cursor: none;
        display: none;
        pointer-events: auto;
    }
    body.focus-mode .focus-mode-hotspot { display: block; }
    /* Focus Mode */
    body.focus-mode .header,
    body.focus-mode .scroll-progress,
    body.focus-mode .left-rail,
    body.focus-mode #statsWidget,
    body.focus-mode #keyboardLegend {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
    }
    body.focus-mode .image-layer,
    body.focus-mode .hover-image,
    body.focus-mode .edge-blur,
    body.focus-mode .vignette {
        opacity: 0 !important;
        pointer-events: none;
        transition: opacity 0.25s ease;
    }
    body.focus-mode.image-active .sentence:not(.active) {
        opacity: var(--sentence-dimmed-opacity) !important;
        color: var(--sentence-dimmed-color) !important;
    }
    body.focus-mode .sentence.active { text-shadow: none; }
    @keyframes focusPulse {
        0%, 100% { box-shadow: 0 2px 0 0 var(--accent); }
        50%       { box-shadow: 0 2px 0 0 color-mix(in srgb, var(--accent) 50%, transparent); }
    }
    body.focus-mode .sentence.active { animation: focusPulse 1.8s ease-in-out infinite; }

/* ===================================
   COMPOSE MODE
   =================================== */

/* Compose toggle button — bottom left of left rail */
.compose-toggle {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: var(--z-ui);
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--ink-3);
    cursor: pointer;
    display: none; /* hidden on desktop — music widget takes this slot */
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}
.compose-toggle:hover {
    background: var(--hover-tint);
    border-color: var(--accent);
    color: var(--accent);
    transform: translateX(-50%) scale(1.08);
}
.compose-toggle.active {
    background: var(--accent);
    border-color: var(--accent);
    color: var(--bg-color);
    transform: translateX(-50%);
}
.compose-toggle svg { width: 14px; height: 14px; fill: currentColor; }

/* Compose bar — draggable floating widget */
.compose-bar {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(calc(100% + 40px));
    width: 600px;
    max-width: calc(100vw - 48px);
    z-index: calc(var(--z-ui) + 10);
    background: var(--surface-raised);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    padding: 0 0 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    transition: transform 0.35s cubic-bezier(0.25, 1, 0.5, 1),
                opacity 0.35s ease;
    pointer-events: none;
    opacity: 0;
    box-shadow: 0 8px 40px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.15);
}
body.compose-mode .compose-bar {
    transform: translateX(-50%) translateY(0);
    pointer-events: auto;
    opacity: 1;
}

/* Compose drag handle */
.compose-drag-handle {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 28px;
    cursor: grab;
    color: var(--ink-3);
    font-size: 11px;
    letter-spacing: 0.1em;
    opacity: 0.4;
    border-bottom: 1px solid var(--border);
    border-radius: 10px 10px 0 0;
    user-select: none;
    transition: opacity 0.15s ease;
    flex-shrink: 0;
}
.compose-drag-handle:hover { opacity: 0.8; cursor: grab; }
.compose-drag-handle:active { cursor: grabbing; }

/* Padding wrapper for content below drag handle */
.compose-bar-inner {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 10px 20px 0;
}

/* Mobile: revert to pinned full-width bar */
@media (max-width: 768px) {
    .compose-bar {
        bottom: 0;
        left: 0 !important;
        right: 0;
        width: 100%;
        max-width: 100%;
        transform: translateY(100%) !important;
        border-radius: 0;
        border-left: none;
        border-right: none;
        border-bottom: none;
        box-shadow: none;
        padding: 0 0 8px;
    }
    body.compose-mode .compose-bar {
        transform: translateY(0) !important;
    }
    .compose-drag-handle { display: none; }
    .compose-bar-inner { padding: 8px 14px 0; gap: 6px; }
}

/* Compose header row */
.compose-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
}
.compose-header-controls {
    display: flex;
    align-items: center;
    gap: 6px;
}
.compose-label {
    font-family: var(--ui-font);
    font-size: 9px;
    color: var(--ink-3);
    text-transform: uppercase;
    letter-spacing: 0.12em;
    opacity: 0.6;
    flex-shrink: 0;
}
.compose-chapter-select {
    font-family: var(--ui-font);
    font-size: 9px;
    color: var(--ink-2);
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 3px 8px;
    cursor: pointer;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    appearance: none;
    -webkit-appearance: none;
    outline: none;
    transition: border-color 0.15s ease, color 0.15s ease;
    max-width: 140px;
}
.compose-chapter-select:focus,
.compose-chapter-select:hover {
    border-color: var(--accent);
    color: var(--accent);
}
.compose-chapter-select option {
    background: var(--surface-raised);
    color: var(--ink);
}

/* Hints tooltip button — mobile only */
.compose-hints-btn {
    display: none;
    background: none;
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--ink-3);
    padding: 3px 5px;
    cursor: pointer;
    transition: all 0.15s ease;
    line-height: 0;
    flex-shrink: 0;
}
.compose-hints-btn svg { width: 13px; height: 13px; }
.compose-hints-btn:hover { border-color: var(--accent); color: var(--accent); }
@media (max-width: 768px) {
    .compose-hints-btn { display: flex; align-items: center; justify-content: center; }
}

/* Close button — always present, styled like a small key */
.compose-close-btn {
    background: none;
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--ink-3);
    font-family: var(--ui-font);
    font-size: 10px;
    padding: 3px 7px;
    cursor: pointer;
    transition: all 0.15s ease;
    line-height: 1;
    flex-shrink: 0;
}
.compose-close-btn:hover { border-color: var(--accent); color: var(--accent); }

/* Desktop word count inline in header */
.compose-wordcount-desktop {
    white-space: nowrap;
    opacity: 0.5;
}
@media (max-width: 768px) {
    .compose-wordcount-desktop { display: none; }
}

/* Input — full width */
.compose-input {
    width: 100%;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 14px;
    font-family: var(--body-font);
    font-size: clamp(16px, 2vw, 20px);
    color: var(--ink);
    outline: none;
    resize: none;
    min-height: 48px;
    max-height: 180px;
    line-height: 1.6;
    transition: border-color 0.2s ease, background 0.2s ease;
    caret-color: var(--accent);
    overflow-y: auto;
    box-sizing: border-box;
}
.compose-input::placeholder { color: var(--ink-3); opacity: 0.5; }
.compose-input:focus {
    border-color: rgba(218,165,32,0.4);
    background: rgba(255,255,255,0.06);
}

/* Desktop hint row */
.compose-hints-desktop {
    display: flex;
    gap: 12px;
    align-items: center;
    padding-bottom: 4px;
}
@media (max-width: 768px) {
    .compose-hints-desktop { display: none; }
}
.compose-hint {
    font-family: var(--ui-font);
    font-size: 8px;
    color: var(--ink-3);
    letter-spacing: 0.06em;
    opacity: 0.5;
    white-space: nowrap;
}
.compose-hint kbd {
    font-family: var(--ui-font);
    font-size: 8px;
    background: rgba(255,255,255,0.08);
    border: 1px solid var(--border);
    border-radius: 2px;
    padding: 1px 4px;
    color: var(--ink-2);
}
.compose-hint-divider {
    width: 1px;
    height: 10px;
    background: var(--border);
    flex-shrink: 0;
}

/* Compose mode — no padding push needed, widget floats */
body.compose-mode .parallax-container {
    padding-bottom: 0;
}

/* Compose mode — stack sentences as individual lines */
body.compose-mode .sentence,
body.compose-mode .chapter-break,
body.compose-mode .subchapter-break {
    display: flex;
    align-items: baseline;
    padding: 4px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    position: relative;
}
body.compose-mode .sentence:last-child,
body.compose-mode .chapter-break:last-child,
body.compose-mode .subchapter-break:last-child {
    border-bottom: none;
}

/* Drag handle injected per-sentence in compose mode */
.sentence-drag-handle {
    display: none;
    flex-shrink: 0;
    width: 20px;
    margin-right: 10px;
    align-self: center;
    cursor: grab;
    color: var(--ink-3);
    opacity: 0;
    transition: opacity 0.15s ease, color 0.15s ease;
    font-size: 14px;
    line-height: 1;
    letter-spacing: -1px;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}
.sentence-drag-handle:active { cursor: grabbing; }
body.compose-mode .sentence-drag-handle,
body.compose-mode .chapter-break .sentence-drag-handle,
body.compose-mode .subchapter-break .sentence-drag-handle { display: flex; align-items: center; justify-content: center; }
body.compose-mode .pullquote-break .sentence-drag-handle { display: flex; align-items: center; justify-content: center; }
body.compose-mode .sentence:hover .sentence-drag-handle,
body.compose-mode .chapter-break:hover .sentence-drag-handle,
body.compose-mode .subchapter-break:hover .sentence-drag-handle { opacity: 0.4; }
body.compose-mode .sentence:hover .sentence-drag-handle:hover,
body.compose-mode .chapter-break:hover .sentence-drag-handle:hover,
body.compose-mode .subchapter-break:hover .sentence-drag-handle:hover { opacity: 1; color: var(--accent); }

/* Drag-over drop target indicator */
body.compose-mode .sentence.drag-over-above,
body.compose-mode .chapter-break.drag-over-above,
body.compose-mode .subchapter-break.drag-over-above {
    box-shadow: inset 0 2px 0 0 var(--accent);
}
body.compose-mode .sentence.drag-over-below,
body.compose-mode .chapter-break.drag-over-below,
body.compose-mode .subchapter-break.drag-over-below {
    box-shadow: inset 0 -2px 0 0 var(--accent);
}
body.compose-mode .sentence.dragging,
body.compose-mode .chapter-break.dragging,
body.compose-mode .subchapter-break.dragging {
    opacity: 0.35;
}

/* Editing sentence highlight */
.sentence.editing {
    outline: 1px solid rgba(218,165,32,0.5);
    outline-offset: 4px;
    border-radius: 2px;
    background: rgba(218,165,32,0.04) !important;
}

/* New sentence animation */
@keyframes sentenceEnter {
    from { opacity: 0; transform: translateY(8px); }
    to   { opacity: 1; transform: translateY(0); }
}
.sentence.just-added {
    animation: sentenceEnter 0.4s cubic-bezier(0.25, 1, 0.5, 1) forwards;
}

/* Compose mode — mode cluster writer keys */
.mode-key.compose-key { display: none; }
body.compose-mode .mode-key.compose-key { display: flex; }
body.compose-mode .mode-key.reader-key { display: none; }

/* Image map picker overlay */
.imagemap-picker {
    position: fixed;
    inset: 0;
    z-index: calc(var(--z-ui) + 20);
    background: rgba(0,0,0,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    padding: 80px 40px 40px;
    gap: 24px;
    overflow-y: auto;
}
.imagemap-picker.open { display: flex; }
.imagemap-picker-header {
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.imagemap-picker-title {
    font-family: var(--ui-font);
    font-size: 10px;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.12em;
}
.imagemap-picker-phrase {
    font-family: var(--body-font);
    font-size: 20px;
    color: var(--ink);
    border-bottom: 1px solid var(--border);
    padding-bottom: 12px;
}
.imagemap-picker-input-row {
    width: 100%;
    max-width: 900px;
    display: flex;
    gap: 8px;
}
.imagemap-url-input {
    flex: 1;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 14px;
    font-family: var(--ui-font);
    font-size: 11px;
    color: var(--ink);
    outline: none;
    caret-color: var(--accent);
    transition: border-color 0.2s ease;
}
.imagemap-url-input:focus { border-color: rgba(218,165,32,0.4); }
.imagemap-url-input::placeholder { color: var(--ink-3); opacity: 0.5; }
.imagemap-url-confirm {
    padding: 10px 18px;
    background: var(--accent);
    border: none;
    border-radius: 4px;
    color: var(--bg-color);
    font-family: var(--ui-font);
    font-size: 10px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    cursor: pointer;
    transition: filter 0.15s ease;
}
.imagemap-url-confirm:hover { filter: brightness(1.1); }
.imagemap-picker-close {
    position: absolute;
    top: 24px;
    right: 32px;
    background: none;
    border: none;
    color: var(--ink-3);
    font-family: var(--ui-font);
    font-size: 11px;
    cursor: pointer;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    transition: color 0.15s ease;
}
.imagemap-picker-close:hover { color: var(--accent); }
.imagemap-grid {
    width: 100%;
    max-width: 900px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 12px;
}
.imagemap-grid-item {
    aspect-ratio: 4/3;
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
    border: 2px solid transparent;
    transition: border-color 0.15s ease, transform 0.15s ease;
    position: relative;
}
.imagemap-grid-item:hover {
    border-color: var(--accent);
    transform: scale(1.02);
}
.imagemap-grid-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}
.imagemap-grid-item .item-phrase {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0,0,0,0.7);
    font-family: var(--ui-font);
    font-size: 8px;
    color: var(--ink-2);
    padding: 4px 6px;
    letter-spacing: 0.04em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    opacity: 0;
    transition: opacity 0.15s ease;
}
.imagemap-grid-item:hover .item-phrase { opacity: 1; }

/* HUD compose button — shows in reader mode on mobile */
.hud-compose-btn {
    display: none;
    color: var(--ink-3);
    transition: color 0.15s ease, background 0.15s ease;
}
.hud-compose-btn.active {
    color: var(--accent);
    background: var(--hover-tint);
}

/* HUD submit button — compose mode on mobile, accent colored */
.hud-submit-btn {
    display: none;
    color: var(--bg-color) !important;
    background: var(--accent) !important;
    border-color: var(--accent) !important;
    transition: opacity 0.15s ease, filter 0.15s ease;
}
.hud-submit-btn:disabled { opacity: 0.35 !important; filter: none; }

/* HUD nav group — prev/next side by side */
.hud-nav-group {
    display: flex;
    align-items: center;
    gap: 2px;
}

@media (max-width: 768px) {
    /* Reader mode: show compose toggle */
    .hud-compose-btn { display: flex; }
    /* Compose mode: swap compose toggle for submit */
    body.compose-mode .hud-submit-btn { display: flex; }
    body.compose-mode .hud-compose-btn { display: none; }
    /* Mobile: show compose fob (music widget replaces it on desktop) */
    .compose-toggle { display: flex; }
}


/* Writer stats morph */
body.compose-mode #statSentencesSeen::after { content: ''; }
.stat-label-writer { display: none; }
body.compose-mode .stat-label-reader { display: none; }
body.compose-mode .stat-label-writer { display: block; }

/* Compose mode body offset for fixed bar */
body.compose-mode { padding-bottom: 0; }

@media (max-width: 768px) {
    .compose-input { font-size: 16px; }
    .imagemap-picker { padding: 60px 16px 24px; }
    .imagemap-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
}

/* Chapter dropdown footer */
.chapter-dropdown-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px 12px;
    border-top: 1px solid var(--border);
    margin-top: 4px;
    flex-shrink: 0;
}
.dropdown-copyright {
    font-family: var(--ui-font);
    font-size: 8px;
    color: var(--ink-3);
    letter-spacing: 0.08em;
    opacity: 0.5;
    text-transform: uppercase;
}
.dropdown-readme {
    font-family: var(--ui-font);
    font-size: 8px;
    color: var(--ink-3);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    text-decoration: none;
    opacity: 0.5;
    transition: opacity 0.15s ease, color 0.15s ease;
}
.dropdown-readme:hover {
    opacity: 1;
    color: var(--accent);
}

    /* ===================================
       MUSIC PLAYER WIDGET
       desktop: bottom-center, matches stats widget height when collapsed
       =================================== */
    .music-player {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: var(--z-ui);
        width: 280px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 6px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        box-shadow: 0 2px 12px rgba(0,0,0,0.3);
        transition: background 0.35s ease, border-color 0.35s ease;
        user-select: none;
        pointer-events: auto;
        touch-action: none;
        will-change: transform;
        isolation: isolate;
        overflow: hidden;
        /* height matches stats widget via padding — don't set explicit height */
    }
    /* Once dragged, JS removes centering and switches to absolute left/top */
    .music-player.dragged {
        transform: none;
        left: auto;
    }

    /* Drag handle — always full width, always grabbable */
    .music-player-drag {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 3px 6px 3px 4px; /* tight to match stats widget height */
        cursor: grab;
        user-select: none;
        min-height: 38px; /* matches stats widget ~height */
        border-bottom: 1px solid transparent;
        transition: border-color 0.2s ease;
        -webkit-tap-highlight-color: transparent;
    }
    .music-player-drag:active { cursor: grabbing; }
    .music-player.expanded .music-player-drag { border-bottom-color: var(--border); }

    .music-drag-dots {
        font-family: sans-serif;
        color: var(--ink-3);
        font-size: 12px;
        letter-spacing: -3px;
        opacity: 0.4;
        line-height: 1;
        flex-shrink: 0;
        padding-right: 4px;
        border-right: 1px solid var(--border);
        align-self: stretch;
        display: flex;
        align-items: center;
        margin-right: 2px;
    }

    /* Transport inline in header (always visible) */
    .music-transport {
        display: flex;
        align-items: center;
        gap: 4px;
        flex-shrink: 0;
    }
    .music-btn {
        width: 28px; height: 28px;
        border-radius: 50%;
        background: rgba(255,255,255,0.04);
        border: 1px solid var(--border);
        color: var(--ink-3);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.12s ease;
        flex-shrink: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }
    .music-btn:hover { background: var(--hover-tint); border-color: var(--accent); color: var(--accent); }
    .music-btn:active { transform: scale(0.86); }
    .music-btn svg { width: 12px; height: 12px; fill: currentColor; pointer-events: none; }
    .music-btn.play-btn {
        width: 32px; height: 32px;
        background: var(--accent);
        border-color: var(--accent);
        color: var(--bg-color);
    }
    .music-btn.play-btn:hover { filter: brightness(1.12); background: var(--accent); }

    /* Now-playing info (center of header) */
    .music-now-playing {
        flex: 1;
        min-width: 0;
        padding: 0 4px;
    }
    .music-now-name {
        font-family: var(--ui-font);
        font-size: 9px;
        font-weight: 700;
        color: var(--ink);
        letter-spacing: 0.03em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.3;
    }
    .music-now-status {
        font-family: var(--ui-font);
        font-size: 7px;
        color: var(--ink-3);
        letter-spacing: 0.05em;
        text-transform: uppercase;
        opacity: 0.5;
        line-height: 1.3;
    }
    @keyframes musicPulse { 0%,100%{opacity:1} 50%{opacity:0.3} }
    .music-now-status.playing { color: var(--accent); opacity: 1; animation: musicPulse 2.2s ease-in-out infinite; }

    /* Expand/collapse toggle */
    .music-player-collapse {
        background: none;
        border: none;
        color: var(--ink-3);
        font-size: 14px;
        font-weight: 300;
        cursor: pointer;
        padding: 4px 2px;
        line-height: 1;
        transition: color 0.15s ease;
        flex-shrink: 0;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        min-width: 24px;
        text-align: center;
    }
    .music-player-collapse:hover { color: var(--accent); }

    /* Compose mode: inline play/pause replaces collapse button */
    .music-header-playpause {
        display: none;
        width: 22px; height: 22px;
        border-radius: 50%;
        background: var(--accent);
        border: none;
        color: var(--bg-color);
        cursor: pointer;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        padding: 0;
        transition: filter 0.15s ease;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }
    .music-header-playpause:hover { filter: brightness(1.18); }
    .music-header-playpause svg { width: 10px; height: 10px; fill: currentColor; pointer-events: none; }

    /* Expanded body — track list */
    .music-player-body {
        padding: 6px 8px 8px;
        display: none; /* collapsed by default */
    }
    .music-player.expanded .music-player-body { display: block; }

    .music-track-list {
        display: flex;
        flex-direction: column;
        gap: 1px;
    }
    .music-track {
        display: flex;
        align-items: center;
        gap: 7px;
        padding: 6px 6px;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.12s ease;
        border: 1px solid transparent;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }
    .music-track:hover { background: var(--hover-tint); }
    .music-track.active {
        background: var(--hover-tint-strong);
        border-color: color-mix(in srgb, var(--accent) 22%, transparent);
    }
    .music-track-num {
        font-family: var(--ui-font);
        font-size: 8px;
        color: var(--ink-3);
        width: 14px;
        text-align: center;
        flex-shrink: 0;
        opacity: 0.45;
    }
    .music-track.active .music-track-num { color: var(--accent); opacity: 1; }
    .music-track-info { flex: 1; min-width: 0; }
    .music-track-name {
        font-family: var(--ui-font);
        font-size: 9px;
        color: var(--ink-2);
        letter-spacing: 0.04em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.35;
    }
    .music-track.active .music-track-name { color: var(--accent); }
    .music-track-sub {
        font-family: var(--ui-font);
        font-size: 7px;
        color: var(--ink-3);
        letter-spacing: 0.03em;
        opacity: 0.5;
        line-height: 1.3;
    }

    /* Off-screen SC iframe host */
    #musicIframeContainer {
        position: fixed;
        left: -9999px; top: -9999px;
        width: 1px; height: 1px;
        overflow: hidden;
        pointer-events: none;
    }

    /* Compose mode: hide body + transport, show header play button */
    body.compose-mode .music-player-body { display: none !important; }
    body.compose-mode .music-transport { display: none; }
    body.compose-mode .music-player-collapse { display: none; }
    body.compose-mode .music-header-playpause { display: flex; }
    body.compose-mode .music-now-playing { padding-right: 4px; }

    /* H / concealed */
    body.ui-hidden .music-player { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
    body.ui-concealed .music-player { opacity: 0 !important; pointer-events: none !important; }

    /* iOS Safari: push above home indicator */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
        .music-player {
            bottom: calc(20px + env(safe-area-inset-bottom));
        }
        .music-player.dragged {
            bottom: auto; /* dragged position uses top, ignore safe area override */
        }
    }

    @media (max-width: 768px) {
        .music-player {
            bottom: calc(84px + env(safe-area-inset-bottom)); /* above mobile HUD */
            left: 50%;
            transform: translateX(-50%);
            width: calc(100vw - 32px);
            max-width: 300px;
        }
        .music-player.dragged { transform: none; left: auto; bottom: auto; }
    }

    </style>
</head>
<body class="theme-newspaper">
    <!-- ════ PAGE LOADER ════ -->
    <div id="pageLoader">
        <video src="https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/soferocious.mp4"
               muted autoplay loop playsinline preload="auto" aria-hidden="true"></video>
        <div class="loader-overlay">
            <span class="loader-paw">🐾</span>
            <span class="loader-wordmark">Wolfgang</span>
            <div class="loader-bar-track"><div class="loader-bar-fill"></div></div>
        </div>
    </div>

    <!-- Skip navigation for keyboard/AT users -->
    <a href="#stream" class="skip-link">Skip to content</a>
    <!-- Screen reader live announcer for sentence navigation -->
    <div id="srAnnouncer" aria-live="assertive" aria-atomic="true" class="sr-only"></div>



    <div class="toast-container" id="toastContainer" aria-live="polite" aria-atomic="false"></div>
    <div class="close-hotspot grid-close-hotspot" id="gridCloseHotspot" aria-label="Move cursor here to close (top-right corner)"></div>
    <div class="close-hotspot split-close-hotspot" id="splitCloseHotspot" aria-label="Move cursor here to close (top-right corner)"></div>
    <div class="close-hotspot rotate-close-hotspot" id="rotateCloseHotspot" aria-label="Move cursor here to close (top-right corner)"></div>
    <div class="ui-hidden-hotspot" id="uiHiddenHotspot" aria-label="Move cursor here to restore UI"></div>
    <div class="focus-mode-hotspot" id="focusModeHotspot" aria-label="Move cursor here to exit focus mode"></div>
    
    <div class="rotate-warning" id="rotateWarning">
        <svg viewBox="0 0 24 24"><path d="M4 7.59l5-5c.78-.78 2.05-.78 2.83 0L20 10.76c.78.78.78 2.05 0 2.83L11.83 21.76c-.78.78-2.05.78-2.83 0l-5-5c-.78-.78-.78-2.05 0-2.83L4 7.59zM9 19.17l8.17-8.17L9 2.83 2.83 9 9 19.17zM17 12h-2v2h2v-2zm0-4h-2v2h2V8zm0-4h-2v2h2V4z"/></svg>
        <p>Please rotate your device to landscape for Split View.</p>
        <p style="font-size:11px;opacity:0.5;margin-top:12px;font-family:var(--ui-font);">TAP TO DISMISS</p>
    </div>

    <div id="keyboardLegend" class="keyboard-legend" title="Drag to move">
        <div class="drag-handle">⋮⋮</div>
        <div class="k-group">
            <div class="k-row">
                <div class="k-key" id="keyPrevSentence" aria-label="Previous Sentence">↑<span class="k-tooltip">Prev Sentence</span></div>
            </div>
            <div class="k-row">
                <div class="k-key" id="keyPrevChapter" aria-label="Previous Chapter">←<span class="k-tooltip">Prev Chapter</span></div>
                <div class="k-key" id="keyNextSentence" aria-label="Next Sentence">↓<span class="k-tooltip">Next Sentence</span></div>
                <div class="k-key" id="keyNextChapter" aria-label="Next Chapter">→<span class="k-tooltip">Next Chapter</span></div>
            </div>
        </div>
    </div>

    <div id="statsWidget" class="stats-widget" title="Drag to move" aria-label="Reading stats and navigation">
        <div class="stats-drag-handle">⋮⋮</div>
        <!-- Compose button — mobile HUD only (reader mode) -->
        <button class="hud-nav-btn hud-compose-btn" id="hudComposeBtn" aria-label="Toggle compose mode" title="Compose">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
        </button>
        <!-- Submit button — compose mode on mobile only -->
        <button class="hud-nav-btn hud-submit-btn" id="hudSubmitBtn" aria-label="Commit sentence" title="Commit sentence">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
        </button>
        <div class="hud-divider"></div>
        <div class="stats-group">
            <div class="stat-item">
                <span class="stat-value" id="statSentencesSeen">1</span>
                <span class="stat-label stat-label-reader">Sentences</span>
                <span class="stat-label stat-label-writer">Written</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="statBracketsOpened">0</span>
                <span class="stat-label stat-label-reader">Brackets</span>
                <span class="stat-label stat-label-writer">Notes</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="statChaptersRead">1</span>
                <span class="stat-label stat-label-reader">Chapters</span>
                <span class="stat-label stat-label-writer">Chapters</span>
            </div>
        </div>
        <div class="hud-divider"></div>
        <!-- Nav grouped together -->
        <div class="hud-nav-group">
            <button class="hud-nav-btn" id="hudPrevBtn" aria-label="Previous Sentence" title="Previous (long-press for prev chapter)">
                <svg viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/></svg>
            </button>
            <button class="hud-nav-btn" id="hudNextBtn" aria-label="Next Sentence" title="Next (long-press for next chapter)">
                <svg viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>
            </button>
        </div>
    </div>

    <div class="image-grid-overlay" id="imageGridOverlay" aria-hidden="true">
        <div class="grid-wireframe-bg" id="gridWireframeBg"></div>
        <div class="grid-content" id="gridContent"></div>
    </div>

    <div id="cursor" aria-hidden="true"><img id="cursor-thumb" alt="" aria-hidden="true"></div>
    
    <div class="left-rail">
        <div class="lens-control-container">
            <button class="toast-rail-btn" id="toastRailBtn" title="Hints &amp; tips" aria-label="Show hints">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
                </svg>
                <span class="toast-rail-dot" id="toastRailDot"></span>
            </button>
            <div class="accessibility-controls">
                <button class="accessibility-btn" id="accessibilityIncrease" aria-label="Increase accessibility" title="Increase">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </button>
                <div class="accessibility-level" id="accessibilityLevel">
                    <div class="level-indicator"></div>
                    <div class="level-indicator"></div>
                    <div class="level-indicator active"></div>
                    <div class="level-indicator"></div>
                    <div class="level-indicator"></div>
                </div>
                <button class="accessibility-btn" id="accessibilityDecrease" aria-label="Decrease accessibility" title="Decrease">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </button>
            </div>
        </div>
    </div>



    <!-- Compose bar — floating widget -->
    <div class="compose-bar" id="composeBar" aria-label="Compose">
        <div class="compose-drag-handle" id="composeDragHandle">⋮⋮</div>
        <div class="compose-bar-inner">
            <div class="compose-header">
                <span class="compose-label">Compose</span>
                <div class="compose-header-controls">
                    <select class="compose-chapter-select" id="composeChapterSelect" aria-label="Select chapter"></select>
                    <!-- Desktop: word count inline -->
                    <span class="compose-hint compose-wordcount-desktop" id="composeWordCount">0 words · 0 sentences</span>
                    <!-- Mobile: tooltip/hints icon triggers toast -->
                    <button class="compose-hints-btn" id="composeHintsBtn" aria-label="Show keyboard hints" title="Keyboard hints">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg>
                    </button>
                    <!-- Close — always visible -->
                    <button class="compose-close-btn" id="composeMobileClose" aria-label="Exit compose mode" title="Exit Compose">✕</button>
                </div>
            </div>
            <textarea
                class="compose-input"
                id="composeInput"
                placeholder="Write that thought."
                rows="2"
                aria-label="Compose sentence"
                spellcheck="true"
            ></textarea>
            <!-- Desktop hint row — hidden on mobile -->
            <div class="compose-hints compose-hints-desktop">
                <span class="compose-hint"><kbd>Enter</kbd> commit</span>
                <div class="compose-hint-divider"></div>
                <span class="compose-hint"><kbd>Shift+Enter</kbd> line break</span>
                <div class="compose-hint-divider"></div>
                <span class="compose-hint"><kbd>###:</kbd> chapter</span>
                <div class="compose-hint-divider"></div>
                <span class="compose-hint"><kbd>##:</kbd> section</span>
                <div class="compose-hint-divider"></div>
                <span class="compose-hint"><kbd>#:</kbd> break</span>
                <div class="compose-hint-divider"></div>
                <span class="compose-hint"><kbd>↑↓</kbd> navigate</span>
            </div>
        </div><!-- /.compose-bar-inner -->
    </div>

    <!-- Image map picker overlay -->
    <div class="imagemap-picker" id="imagemapPicker" aria-hidden="true">
        <button class="imagemap-picker-close" id="imagemapPickerClose">✕ Close</button>
        <div class="imagemap-picker-header">
            <div class="imagemap-picker-title">Map image to phrase</div>
            <div class="imagemap-picker-phrase" id="imagemapPickerPhrase">Select a phrase to map</div>
        </div>
        <div class="imagemap-picker-input-row">
            <input type="url" class="imagemap-url-input" id="imagemapUrlInput" placeholder="Paste image URL — or pick from library below" />
            <button class="imagemap-url-confirm" id="imagemapUrlConfirm">Map it</button>
        </div>
        <div class="imagemap-grid" id="imagemapGrid"></div>
    </div>
    
    <header class="header">
        <div class="brand-container">
            <div class="brand" id="brandLogo" aria-label="Open chapter menu">
                <span>For Wolfgang</span>
                <span class="brand-dropdown-icon">▼</span>
            </div>
            <div class="chapter-dropdown" id="chapterDropdown" aria-hidden="true">
                <div class="chapter-dropdown-header" id="chapterDropdownHeader">
                    <span class="dropdown-drag-handle">⋮⋮</span>
                    <h3>Chapters</h3>
                </div>
                <ul class="chapter-dropdown-list" id="chapterDropdownList"></ul>
                <div class="chapter-dropdown-footer">
                    <span class="dropdown-copyright">&copy; 2026 Zack Gort</span>
                    
                </div>
            </div>
        </div>

        <div class="mode-cluster" id="modeCluster" title="Drag to move" aria-label="Mode controls">
            <div class="mode-drag-handle">⋮⋮</div>
            <!-- Reader keys: Compose, Grid, Notes, Focus, Read, Layout, Theme -->
            <button class="mode-key reader-key" id="modeKeyCompose" aria-label="Toggle compose mode" title="Compose">
                <span class="mode-key-label">✏</span>
                <span class="mode-key-desc">Compose</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyG" aria-label="Toggle image grid (G)" title="G — Image Grid">
                <span class="mode-key-label">G</span>
                <span class="mode-key-desc">Grid</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyBrackets" aria-label="Toggle all annotations" title="Toggle all bracket annotations">
                <span class="mode-key-label">[ ]</span>
                <span class="mode-key-desc">Notes</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyF" aria-label="Toggle focus mode (F)" title="F — Focus Mode">
                <span class="mode-key-label">F</span>
                <span class="mode-key-desc">Focus</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyH" aria-label="Toggle read mode (H)" title="H — Read Mode">
                <span class="mode-key-label">H</span>
                <span class="mode-key-desc">Read</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyL" aria-label="Toggle layout (L)" title="L — Layout">
                <span class="mode-key-label">L</span>
                <span class="mode-key-desc">Layout</span>
            </button>
            <button class="mode-key reader-key" id="modeKeyT" aria-label="Toggle theme (T)" title="T — Theme">
                <span class="mode-key-label">T</span>
                <span class="mode-key-desc">Theme</span>
            </button>
            <!-- Writer keys (compose mode only) -->
            <button class="mode-key compose-key" id="composeKeyBracket" aria-label="Insert annotation [+]" title="Insert bracket annotation">
                <span class="mode-key-label">[ ]</span>
                <span class="mode-key-desc">Note</span>
            </button>
            <button class="mode-key compose-key" id="composeKeyChapter" aria-label="Insert chapter break" title="Insert chapter ###:">
                <span class="mode-key-label">###:</span>
                <span class="mode-key-desc">Chapter</span>
            </button>
            <button class="mode-key compose-key" id="composeKeySubchapter" aria-label="Insert subchapter break" title="Insert subchapter ##:">
                <span class="mode-key-label">##:</span>
                <span class="mode-key-desc">Section</span>
            </button>
            <button class="mode-key compose-key" id="composeKeyPullquote" aria-label="Insert pull-quote >>:" title="Insert pull-quote >>:Voice|Quote">
                <span class="mode-key-label">>></span>
                <span class="mode-key-desc">Voice</span>
            </button>
            <button class="mode-key compose-key" id="composeKeyBreak" aria-label="Insert line break #:" title="Insert line break #:">
                <span class="mode-key-label">#:</span>
                <span class="mode-key-desc">Break</span>
            </button>
            <button class="mode-key compose-key" id="composeKeyImage" aria-label="Map image to phrase" title="Map image to phrase">
                <span class="mode-key-label">IMG</span>
                <span class="mode-key-desc">Map</span>
            </button>
            <button class="mode-key compose-key reader-key" id="modeKeyTCompose" aria-label="Toggle theme (T)" title="T — Theme">
                <span class="mode-key-label">T</span>
                <span class="mode-key-desc">Theme</span>
            </button>
            <button class="mode-key compose-key" id="composeKeyDelete" aria-label="Delete active sentence" title="Delete active sentence">
                <span class="mode-key-label">DEL</span>
                <span class="mode-key-desc">Delete</span>
            </button>
        </div>
    </header>

    <div class="edge-blur" aria-hidden="true"></div>
    <div class="vignette" aria-hidden="true"></div>

    <nav class="scroll-progress" aria-label="Chapter navigation">
        <button class="nav-button prev-sentence" id="prevSentenceBtn" title="Previous Sentence (↑/k)" aria-label="Previous Sentence">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/></svg>
        </button>
        <div class="chapter-progress-container" id="chapterProgressContainer"></div>
        <button class="nav-button next-sentence" id="nextSentenceBtn" title="Next Sentence (↓/j)" aria-label="Next Sentence">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
        </button>
    </nav>

    <main class="curved" id="main-content">
        <div class="parallax-container">
            <div id="imageLayer" class="image-layer">
                <div id="hoverImage" class="hover-image" role="tooltip" aria-hidden="true">
                    <img src="" alt="" id="hoverImageImg" loading="lazy">
                    <video id="hoverImageVideo" muted autoplay loop playsinline preload="none"></video>
                </div>
            </div>
            <div id="textLayer" class="text-layer">
                <article class="stream" id="stream" role="article"></article>
            </div>
        </div>
    </main>

    <!-- Off-screen SC iframe host -->
    <div id="musicIframeContainer"></div>

    <!-- Music Player — bottom-center, replaces compose fob on desktop -->
    <div class="music-player" id="musicPlayer">
        <div class="music-player-drag" id="musicPlayerDrag">
            <span class="music-drag-dots">⋮⋮</span>
            <!-- Transport inline in header -->
            <div class="music-transport">
                <button class="music-btn" id="musicPrevBtn" title="Previous" aria-label="Previous track">
                    <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>
                </button>
                <button class="music-btn play-btn" id="musicPlayBtn" title="Play / Pause" aria-label="Play or pause">
                    <svg id="musicPlayIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <button class="music-btn" id="musicNextBtn" title="Next" aria-label="Next track">
                    <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zm2.5-6 5.5 4V8z"/></svg>
                </button>
            </div>
            <!-- Now playing info -->
            <div class="music-now-playing">
                <div class="music-now-name" id="musicNowName">♪ Wolfgang Walklist</div>
                <div class="music-now-status" id="musicNowStatus">Wolfie's Jams</div>
            </div>
            <!-- Compose mode: play/pause pill (transport hidden in compose) -->
            <button class="music-header-playpause" id="musicHeaderPlay" title="Play / Pause" aria-label="Play or pause">
                <svg id="musicHeaderIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <!-- Expand/collapse toggle -->
            <button class="music-player-collapse" id="musicPlayerCollapse" title="Show tracks" aria-label="Show or hide track list">▾</button>
        </div>
        <div class="music-player-body">
            <div class="music-track-list">
                <div class="music-track" data-track="0">
                    <span class="music-track-num">1</span>
                    <div class="music-track-info">
                        <div class="music-track-name">Walk with Wolfie</div>
                        <div class="music-track-sub">original — guitar</div>
                    </div>
                </div>
                <div class="music-track" data-track="1">
                    <span class="music-track-num">2</span>
                    <div class="music-track-info">
                        <div class="music-track-name">A Sublime Canine</div>
                        <div class="music-track-sub">original — guitar</div>
                    </div>
                </div>
                <div class="music-track" data-track="2">
                    <span class="music-track-num">3</span>
                    <div class="music-track-info">
                        <div class="music-track-name">Beautiful Day</div>
                        <div class="music-track-sub">cover concept — guitar &amp; midi drums</div>
                    </div>
                </div>
                <div class="music-track" data-track="3">
                    <span class="music-track-num">4</span>
                    <div class="music-track-info">
                        <div class="music-track-name">Bad Touch</div>
                        <div class="music-track-sub">cover concept — guitar</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// ===================================
// BATHOS - Complete JavaScript
// ===================================

const CONFIG = {
    TAIL_LENGTH: 12,
    CURSOR_SMOOTHING: 0.35,
    IMAGE_HOVER_DELAY: 120,
    TEXT_PARALLAX_STRENGTH: 0.03,
    IMAGE_PARALLAX_STRENGTH: 0.15,
    CENTER_MAGNET_STRENGTH: 0.25,
    PARALLAX_DAMPING: 0.1,
    SCROLL_THRESHOLD: 30,
    SCROLL_COOLDOWN: 100,
    LONG_PRESS_DURATION: 300,
    FLICK_THRESHOLD: 50
};

const state = {
    hoveredSentence: null,
    expandedBrackets: new Set(),
    imageActive: false,
    layoutMode: 'layered',
    currentSentenceIndex: -1,
    currentChapterIndex: 0,
    allSentenceElements: [],
    chapterStartIndices: [],
    subchapterStartIndices: [],
    gridImages: [],
    mouseX: 0,
    mouseY: 0,
    currentTriggerRect: null,
    imageTimeout: null,
    isTouch: false,
    lastInteractionWasTouch: false,
    scrollCooldownActive: false,
    touchStartY: 0,
    touchStartX: 0,
    touchMoved: false,
    // Stats tracking
    sentencesSeen: new Set(),
    bracketsOpened: 0,
    chaptersRead: new Set(),
    // Chapter-break dropdown opener tracking
    chapterBreakOpener: null,
    lastNavWasKeyboard: false
};

const cursor = { x: 0, y: 0, targetX: 0, targetY: 0, element: null, currentImageElement: null };
const parallax = { text: { x: 0, y: 0, targetX: 0, targetY: 0 }, image: { x: 0, y: 0, targetX: 0, targetY: 0 } };
let composeActive = false; // module-level flag so highlightSentence can read it


// ===================================
// DATA
// ===================================

// ===================================
//Well, wouldn't you know?
//Not broken — just needs some TLC. 
//New bag-buddy — never ever baggage.
//Works over WOOfi.
//Tiny. [cafe photo]
//Carries well. [obvi] 
//Travels well. [obvi]
//Travels comfortably.
//Headphone jack (no mute function)
//Works optimally when nearest.
//Nearer.
//*ahem* — nearest, thank you.



// template    '': '',   

const chapters = [];

const imageMap = {
    'road warrior': 'https://i.ibb.co/Swk4v5Tv/wolfgang000.webp',
    'haircuts': 'https://i.ibb.co/xqv72y7c/mohawk.webp',
    'icecream1': 'https://i.ibb.co/Jj1Pc7bs/theabsolutecutestthingihaveeverseen.webp',
    'ferocious': 'https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/soferocious.mp4',
    'roadworth': 'https://i.ibb.co/wF05mLW2/joyful.webp',
    'brave leg': 'https://i.ibb.co/rfKXyv3q/theveryfirstofclassicwolfgang.jpg',
    'slyd': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/sleepspiral.mp4',
    'Reald': 'https://i.ibb.co/SDBHyLHB/park123.jpg',
    'REALD': 'https://i.ibb.co/6J8QRGXg/sothisiswolfgang.webp',

    'This feels nice': 'https://i.ibb.co/5gPCWkDf/nownamedgivenanappropriatemohawk.webp',
    'Nighty-nite.': 'https://i.ibb.co/Q7qvD3p8/atthismomentidecidedhewasmine.webp',


    'elephant': 'https://i.ibb.co/8g0HH5XG/elephantbywolfgang.webp',

    'Meet Wolfgang': 'https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/Ohmmmm.mp4',
    '"Sweet Wolfgang"': 'https://i.ibb.co/d4SkHwfB/icecream45678.webp',
    'as his name': 'https://i.ibb.co/zWbFdGF8/sowolfgangdiscoveredpupcupsatprettymucheverysheetz.webp',
    'Wolfie for short': 'https://i.ibb.co/83SsR99/thislittledudeexudedsomuchconfidence.webp',
    '"Wolf" by calling': 'https://i.ibb.co/MxGzxSVk/wolfgang00.webp',
    'Woofie-boo': 'https://i.ibb.co/mrsF2PP2/whereiswolfgang.webp',
    'but a name worth becoming': 'https://i.ibb.co/d0MxCR6m/delicious.webp',
    'Chronicles of Wolfgang': 'https://i.ibb.co/Swk4v5Tv/wolfgang000.webp',

    'hero': 'https://i.ibb.co/LXR70BTD/wolfieboop.webp',
    'talks of bravery': 'https://i.ibb.co/3yYzQLjP/braveboy.webp',
    'Of fortitude': 'https://i.ibb.co/twP8m5wP/buildingburgerking.webp',
    'Of rebellion': 'https://i.ibb.co/HTqtChHv/curbyourdog.webp',
    'tale told': 'https://i.ibb.co/CknqHpK/happierinnewyork.webp',
    'inviting hope': 'https://i.ibb.co/G4qDyqZH/surviorandthriverfullcolor.webp',
    'Wanderlust': 'https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/Worldviewwalkieswithwolfgang.mp4',
    'untold woes': 'https://i.ibb.co/r2gFFwNf/oneofwolfgangsfavoriteplaces.webp',
    'avoidance': 'https://i.ibb.co/TMxmFknH/fallinginlove1.jpg', 
    'never again, pal': 'https://i.ibb.co/YBQ5pvfW/fellinlove1.jpg', 
    'pure joy': 'https://i.ibb.co/rKbH2FFx/sweetestwolfgang.webp',
    'resolve': 'https://i.ibb.co/gQPNJXc/xlnexttimeplease.webp',
    'reticence': 'https://i.ibb.co/KJ9pcSh/sowolfiehatedtherain.webp',
    'reflection': 'https://i.ibb.co/BKymJdYK/itshisworld.webp',
    'Amongst those times': 'https://i.ibb.co/rRfMt4Fj/happyboy.webp',
    'moments inbetween': 'https://i.ibb.co/rRfMt4Fj/happyboy.webp',
    'adventure': 'https://i.ibb.co/5XLHJ6h3/assorgrasslass.webp',
    'unique': 'https://i.ibb.co/LXBkfzbw/wolfgangsfinestwork.webp',
    'situations': 'https://i.ibb.co/0Rt0KW93/wolfgangsfinestworkmoment.webp',

    'more of none': 'https://i.ibb.co/KxhDw7nS/loveinastoria.webp',

    'lost and alone': 'https://i.ibb.co/DsT5Ppk/lostinqueens.webp',
    'similar soul': 'https://i.ibb.co/BX5RVPg/wolfgangownsallofmyhoodies.webp',
    'left without care': 'https://i.ibb.co/93bMTmpY/newtothis.webp',

    'You were hungry': 'https://i.ibb.co/BV4C58zX/whenyouletastrangerintoyourhomeandtheygoforyourfridge.jpg',
    'to trust': 'https://i.ibb.co/rfKXyv3q/theveryfirstofclassicwolfgang.jpg',
    'You longingly looked for a lap': 'https://i.ibb.co/KjCG862F/traininghumanonmyfavoritethingtodoperiod.webp',
    'someone to understand': 'https://i.ibb.co/nsp6BwTS/socks1.jpg',
    'think of you': 'https://i.ibb.co/nsp6BwTS/socks1.jpg',
    'try to': 'https://i.ibb.co/hJRKrSTv/socks2.jpg',
    'For someone to ask': 'https://i.ibb.co/93bMTmpY/newtothis.webp',
    'For someone to act': 'https://i.ibb.co/gqbRRr5/mysweetpumpkin.jpg',
    'For someone to give': 'https://i.ibb.co/27c34fPD/allstitchedup.jpg',
    'hand': 'https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/leglift001.mp4',

    'new dad': 'https://i.ibb.co/JjGbm5rh/heydaddy.webp',

    'belong': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/stinkyboy.mp4',
    'know without notice': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/welcomehomebuddy.mp4',
    'found home': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Latenightstroll.mp4',
    'you got your mojo back': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Cityboi.mp4',
    'you have complete agency': 'https://github.com/ZACKGORT/ifimaybefrank/raw/refs/heads/main/mp4/happywalks.mp4',
    'amongst': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/longislandwalks.mp4',
    'New lease — no leash': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Leashlesslove.mp4',
    'You decide': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/wolfgangfearlessbridgecrosser.mp4',
    'true New Yorker': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Earlydayswalkpostsurgeryneverneededaleash.mp4',
    'happy walks': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/happywalks.mp4',
    'loathe a lazy walk': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/lazywalkieswithwolfgang.mp4',
    'while windy walks were wild': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/windyboy.mp4',
    'best walks': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/anesthesia.mp4',

    'calories are real': 'https://i.ibb.co/qfBwLrD/comfort1.webp',
    'Dad just made dinner': 'https://i.ibb.co/kV6CzpWS/comfort2.webp',
    'Dinner was good': 'https://i.ibb.co/M5Pcy9f9/homemademeals.webp',
    'Goodnight.': 'https://i.ibb.co/gMfpCbRW/owl.jpg',

    'Bag-buddy': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Newlife.mp4',
    'Works over WOOfi': 'https://i.ibb.co/DHFBm7HM/hisfavoritecafe.webp',
    'Works under WOOfi': 'https://i.ibb.co/DHFBm7HM/hisfavoritecafe.webp',
    'Heaphone': 'https://i.ibb.co/d0bT8TBD/metallicafanprobably.webp',

    'near': 'https://i.ibb.co/bjK8FYHX/mydreamwastoownacafejustforwolfietohangoutin.webp',
    'nearer': 'https://i.ibb.co/vCYxMRbG/lookiftheysayanythingiamheretokeepyouontask.webp',
    'nearest': 'https://i.ibb.co/vCYxMRbG/lookiftheysayanythingiamheretokeepyouontask.webp',
    

    'is this the real life': 'https://i.ibb.co/nsKMYrDs/sowhatareyouupto.webp',
    'is this just fantasy': 'https://i.ibb.co/JwdP8xFc/floating.webp',
    'caught in a landslide': 'https://i.ibb.co/mCy62tkg/likereallyhatedtherain.webp',
    'escape from reality': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/sleepspiral.mp4',
    'Look to the sky': 'https://i.ibb.co/BKymJdYK/itshisworld.webp',

    'sleepies': 'https://raw.githubusercontent.com/ZACKGORT/ifimaybefrank/main/mp4/Sleepingbeauty.mp4',

    
};
const phraseRegexMap = new Map();
function buildPhraseRegex(phrase) {
    const escaped = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const start = /^\w/.test(phrase) ? '(?<![\\w])' : "(?<![\\w'\"])";
    const end   = /\w$/.test(phrase) ? '(?![\\w])'  : "(?![\\w'\"])";
    return new RegExp(`${start}${escaped}${end}`, 'gi');
}
Object.keys(imageMap).forEach(phrase => {
    phraseRegexMap.set(phrase, buildPhraseRegex(phrase));
});

const narrative = `

**"Elephant** Pees In River" [a post-modern abstract impressionist performance made manifest as living graffiti. Brilliant!] #:— *by* **Sweet Wolfgang** • NYC • circa 2023 • Pee-formance Artist 

###:The Sweetest.

**Meet Wolfgang**. [He's a very good boy.] 
Full name, "Sweet Wolfgang". [MY: "sweetie", "sweetheart","sweet baby","my sweet boy"] 
Wolfie for short. [standing stoutly at yay-high] 
"Wolf" by calling. [clearly, born to be]
Woofie-boo, too. [humans always are] 
A name neither chosen, nor given — but a name worth becoming.
[I just watched him for a few days, walking him without knowing what to call him. We went with the usual human names, goofy names, and commonplace names. None stuck. But, my favorite new artist was Mammoth, a band made by a single multi-hyphenate musician named Wolfgang.]
These are the Chronicles of Wolfgang. [written with love]

###: The Chronicles of Wolfgang.
Every hero has a good origin story. 
A tale told with a wagging one. [or flagpole, whichever floats your boat — so masthead, but a little one.]
One that talks of bravery. [super scaries surgery survivor]
A telling of fortitude and resilience. [500 miles from anywhere you know, but a nose-nudge next to your number one.]
A story inviting hope.  
One welcoming wanderlust. [walks away from home, mostly from dad finding working]
With the wholesomeness of untold woes[]
Unveiling vignettes of ~~avoidance~~
— *never again, pal*.
A plot seasoned with pure joy. [absolutely peppered with it. zero salt.]
Capturing moments of resolve.
Reticence.
Reflection.
Living — for the moments inbetween.
Unfolding many an adventure. [all the walkies!]
While many more of none. [absolutely nothing happening, Just us in the moment.']

Living through lessons learned, 
& making the best of *unique situations*. [an artist, and realist]
#:#:
No, this was no ordinary pet poodle []
— the likes of legends, really. []

###: Lost & Found.
When you're lost and alone in Queens, with nowhere to go. [cornered, but in a good corner to find]
And you happen across the path of a similar soul. 
Neglected, abandoned, left without care.
You were hungry. [never again]
You wanted to trust. [That leg lift means everything.]
For someone to understand you. [and wonder]
Or try to. [chicken allergy]
For someone to ask. [Fafo, right?]
For someone to act. [Absolutely unnacceptable to simply ignore.]
For someone to give a stitch. [like, three-thousand stitches]
And of course, for someone's hand. [Classic Wolfgang] 

>>:Wolfie| this feels nice — nighty-nite.

###:Welcome Home, Wolfgang.

That feeling of belong. 
When you know without notice.[Wolfie, then unnamed, making claim to his new domain — also, bath with Old Spice.]
When you're out of place, but you've found home.
Now, you got your mojo back.

##: Walks With Wolfgang.
You have complete agency.
You walk like a true New Yorker. [mildy miffed; furiously focused]
You now walk amongst.
New lease — no leash. [New life.]
You decide your direction.[Wolfgang leads; I happily followed]
You loathe a lazy walk.

City walks. 
Town walks. 
River walks.
Rocky walks.
Really rocky walks.
Walks into things.
Walks into elevators.
Walks out of elevators.



While windy walks were wild.
The best walks were with dad — homeward bound, together.
Because, calories are real. [delapidated doggie]
& dad just made dinner.
Dinner was good.
Goodnight.

###:Found on Side of Road:
>>:FREE| Broken laptop. Bag. Problems.
Well, wouldn't you know?
Not broken — just needs some TLC. 
New bag-buddy — never ever baggage.
Works over WOOfi.
Tiny. [cafe photo]
Headphone jack (no mute function)
Carries well. [obvi] 
Travels well. [obvi]
Travels comfortably.
Works optimally when near.
Nearer.
*ahem* — nearest, thank you.


###: The King From Queens.
Is this the real life?
Is this just fantasy?
Caught in a landslide.
Let's escape from reality. [It's your world, Wolfgang — we're all just living in it']
Open Your Eyes.
Look to the sky.
& See.

###: You're Just a Good Boy. 

##:The Road Warrior.
##:So Helpful
##:Bed Bud
##:The Road Warrior.

You need no sympathy.
You wanted to be close.
You couldn't say it.
You couldn't convey it.
You couldn't help yourself.

>>:Wolfie|*wuf.*

###:Good Day, Now Good Night.
"We had a busy day buddy. You were so helpful. But, it's time to go sleepies. First, we go pee-pee's, then sleep-pee's"
[Good boy]
#:#:
Forever ferocious. Forever a place for you on my lap.

`;


// ===================================
// UTILITY FUNCTIONS
// ===================================
const Utils = {
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => { clearTimeout(timeout); func(...args); };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) { func.apply(this, args); inThrottle = true; setTimeout(() => inThrottle = false, limit); }
        };
    },
    $(selector) { return document.querySelector(selector); },
    $$(selector) { return Array.from(document.querySelectorAll(selector)); }
};

// ===================================
// STATS WIDGET
// ===================================
function pulseStatValue(elId) {
    const el = document.getElementById(elId);
    if (!el) return;
    el.classList.remove('pulse');
    void el.offsetWidth; // reflow to restart animation
    el.classList.add('pulse');
    el.addEventListener('animationend', () => el.classList.remove('pulse'), { once: true });
}

function updateStats() {
    const sentencesEl = document.getElementById('statSentencesSeen');
    const bracketsEl = document.getElementById('statBracketsOpened');
    const chaptersEl = document.getElementById('statChaptersRead');
    if (sentencesEl) sentencesEl.textContent = state.sentencesSeen.size;
    if (bracketsEl) bracketsEl.textContent = state.bracketsOpened;
    if (chaptersEl) chaptersEl.textContent = state.chaptersRead.size;
}

function trackSentence(index) {
    const wasNew = !state.sentencesSeen.has(index);
    state.sentencesSeen.add(index);
    if (wasNew) {
        pulseStatValue('statSentencesSeen');
        updateStats();
    }
    toastBehaviors.onSentenceAdvance();
}

function trackChapter(chapterId) {
    const wasNew = !state.chaptersRead.has(chapterId);
    state.chaptersRead.add(chapterId);
    if (wasNew) {
        pulseStatValue('statChaptersRead');
        updateStats();
        toastBehaviors.onChapterAdvance();
    }
}

function trackBracketOpen() {
    state.bracketsOpened++;
    pulseStatValue('statBracketsOpened');
    updateStats();
    toastBehaviors.onBracketOpened();
}

// ===================================
// TOAST NOTIFICATION SYSTEM
// ===================================
const Toast = (() => {
    const SHOWN_KEY = 'frank_toasts_shown';
    const shown = new Set(JSON.parse(sessionStorage.getItem(SHOWN_KEY) || '[]'));

    function markShown(id) {
        shown.add(id);
        sessionStorage.setItem(SHOWN_KEY, JSON.stringify([...shown]));
    }

    function hasShown(id) { return shown.has(id); }

    let activeToasts = 0;

    function show({ id, icon = '💡', message, actionLabel = null, actionFn = null, duration = 6000, force = false, banner = false, onDismiss = null }) {
        if (!force && hasShown(id)) return;
        if (!banner && activeToasts >= 2) return; // banners bypass stack limit

        const container = document.getElementById('toastContainer');
        if (!container) return;

        const el = document.createElement('div');
        el.className = banner ? 'toast toast-banner' : 'toast';
        el.setAttribute('role', 'status');
        el.innerHTML = `
            <span class="toast-icon">${icon}</span>
            <span class="toast-text">${message}</span>
            ${actionLabel ? `<span class="toast-action" id="toast-action-${id}">${actionLabel}</span>` : ''}
        `;

        // Banners go to body directly so they aren't offset by the rail container
        if (banner) {
            document.body.appendChild(el);
        } else {
            container.appendChild(el);
            activeToasts++;
        }
        markShown(id);

        // Trigger entrance
        requestAnimationFrame(() => {
            requestAnimationFrame(() => el.classList.add('visible'));
        });

        const dismiss = () => {
            if (!el.parentNode) return;
            el.classList.remove('visible');
            el.classList.add('dismissing');
            setTimeout(() => {
                el.remove();
                if (!banner) activeToasts = Math.max(0, activeToasts - 1);
                if (onDismiss) onDismiss();
            }, 350);
        };

        const timer = setTimeout(dismiss, duration);

        if (actionLabel && actionFn) {
            const btn = el.querySelector(`#toast-action-${id}`);
            if (btn) btn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearTimeout(timer);
                dismiss();
                actionFn();
            });
        }

        el.addEventListener('click', () => { clearTimeout(timer); dismiss(); });
    }

    return { show, hasShown };
})();

// ===================================
// TOAST BEHAVIORS (triggers)
// ===================================
const toastBehaviors = (() => {

    const isMobile = () => window.innerWidth <= 768 || state.isTouch;

    // ── Rail dot indicator ──
    function setRailDot(active) {
        const dot = document.getElementById('toastRailDot');
        if (dot) dot.classList.toggle('active', active);
    }

    // ─── Wolfgang factoids ───
    const AMBIENT_POOL = [
        { id: 'amb-0',  message: () => 'Wawa water was Wolfgang\'s favorite.' },
        { id: 'amb-1',  message: () => 'He never needed a leash. Not once.' },
        { id: 'amb-2',  message: () => 'He did not eat the deer steak. A matter of principle.' },
        { id: 'amb-3',  message: () => 'Pup cups at Sheetz changed the calculus of road trips.' },
        { id: 'amb-4',  message: () => 'He sat through every recording session without being asked.' },
        { id: 'amb-5',  message: () => 'Five hundred miles from West Virginia. He slept through most of it.' },
        { id: 'amb-6',  message: () => 'He was happier in New York than anyone expected.' },
        { id: 'amb-7',  message: () => 'He really, genuinely, deeply hated the rain.' },
        { id: 'amb-8',  message: () => 'The mohawk was his era.' },
        { id: 'amb-9',  message: () => 'Named after a musician. Became one himself, in his way.' },
        { id: 'amb-10', message: () => 'Walkies by the river were his favorite.' },
        { id: 'amb-11', message: () => 'He stayed. Without deciding to. That\'s the only way it counts.' },
    ];

    let ambientTimer = null;

    let ambientIndex = 0;
    function scheduleNextAmbient() {
        const delay = 120000 + Math.random() * 120000;
        ambientTimer = setTimeout(() => {
            if (ambientIndex >= AMBIENT_POOL.length) ambientIndex = 0;
            const pick = AMBIENT_POOL[ambientIndex++];
            setRailDot(true);
            Toast.show({
                id: pick.id + '-' + Date.now(),
                icon: '🐾',
                message: typeof pick.message === 'function' ? pick.message() : pick.message,
                duration: 9000, force: true,
                onDismiss: () => setRailDot(false)
            });
            scheduleNextAmbient();
        }, delay);
    }

    // ─── Idle detection ───
    let idleTimer = null;
    let returnTimer = null;
    let lastSentenceIndexAtIdle = -1;
    const IDLE_THRESHOLD = 15000;     // 15s cold idle
    const RETURN_THRESHOLD = 60000;   // 60s away = "return" scenario

    function resetIdleTimer() {
        clearTimeout(idleTimer);
        clearTimeout(returnTimer);
        idleTimer = setTimeout(onIdle, IDLE_THRESHOLD);
    }

    function onIdle() {
        lastSentenceIndexAtIdle = state.currentSentenceIndex;
        // If user goes very long without any input, set a return detection
        returnTimer = setTimeout(() => {
            // returnTimer fires — next interaction triggers onReturn
            document.addEventListener('keydown', onReturn, { once: true });
            document.addEventListener('wheel', onReturn, { once: true });
            document.addEventListener('click', onReturn, { once: true });
            document.addEventListener('touchstart', onReturn, { once: true });
        }, RETURN_THRESHOLD - IDLE_THRESHOLD);

        if (Toast.hasShown('idle-nav')) return;
        setRailDot(true);
        Toast.show({
            id: 'idle-nav',
            icon: '⌨️',
            message: isMobile()
                ? 'Tap the <span class="toast-accent">arrows</span> or swipe to navigate sentence by sentence.'
                : 'Press <span class="toast-accent">Space</span> or <span class="toast-accent">↑↓</span> to navigate sentence by sentence.',
            duration: 12000,
            onDismiss: () => setRailDot(false)
        });
    }

    function onReturn(e) {
        // Clean up other listeners
        ['keydown','wheel','click','touchstart'].forEach(ev =>
            document.removeEventListener(ev, onReturn)
        );
        if (Toast.hasShown('return-welcome-back')) return;
        const sameSentence = state.currentSentenceIndex === lastSentenceIndexAtIdle;
        setRailDot(true);
        Toast.show({
            id: 'return-welcome-back',
            icon: '↩',
            message: sameSentence
                ? 'Welcome back — press <span class="toast-accent">Space</span> to pick up where you left off.'
                : 'Good to have you back. <span class="toast-accent">Keep reading.</span>',
            duration: 12000,
            onDismiss: () => setRailDot(false)
        });
    }

    // ─── Scroll wheel analysis ───
    let wheelTimestamps = [];
    let keyOrButtonUsed = false;
    let wheelOnlyWarned = false;
    let totalWheelCount = 0;
    const WHEEL_WINDOW = 2000;
    const RAPID_WHEEL_THRESHOLD = 5;
    let rapidWheelStage = 0;

    function onWheel() {
        resetIdleTimer();
        const now = Date.now();
        wheelTimestamps.push(now);
        totalWheelCount++;
        wheelTimestamps = wheelTimestamps.filter(t => now - t <= WHEEL_WINDOW);
        const count = wheelTimestamps.length;

        if (count >= RAPID_WHEEL_THRESHOLD) {
            if (rapidWheelStage === 0 && !Toast.hasShown('rapid-wheel-grid')) {
                rapidWheelStage = 1;
                setRailDot(true);
                Toast.show({
                    id: 'rapid-wheel-grid',
                    icon: '▦',
                    message: 'Scrolling fast? <span class="toast-accent">Display</span> shows all imagery at a glance.',
                    actionLabel: 'Open',
                    actionFn: () => toggleImageGrid(),
                    duration: 12000,
                    onDismiss: () => setRailDot(false)
                });
            } else if (rapidWheelStage === 1 && !Toast.hasShown('rapid-wheel-split') && state.layoutMode === 'layered') {
                rapidWheelStage = 2;
                setRailDot(true);
                Toast.show({
                    id: 'rapid-wheel-split',
                    icon: '◫',
                    message: 'Or try <span class="toast-accent">Split View</span> — text uninterrupted, images pinned right.',
                    actionLabel: 'Try it',
                    actionFn: () => { if (state.layoutMode === 'layered') toggleLayout(); },
                    duration: 12000,
                    onDismiss: () => setRailDot(false)
                });
            }
            wheelTimestamps = [];
        }
    }

    function onSingleWheel() {
        if (keyOrButtonUsed || wheelOnlyWarned) return;
        if (totalWheelCount >= 6) {
            wheelOnlyWarned = true;
            setRailDot(true);
            Toast.show({
                id: 'scroll-only-nav',
                icon: '⌨️',
                message: isMobile()
                    ? 'Swipe up/down or tap the <span class="toast-accent">arrows</span> to move sentence by sentence.'
                    : 'Try <span class="toast-accent">Space</span>, <span class="toast-accent">↑↓</span>, or the chapter menu for smoother navigation.',
                actionLabel: 'Chapters',
                actionFn: () => toggleChapterDropdown(),
                duration: 12000,
                onDismiss: () => setRailDot(false)
            });
        }
    }

    function onKeyOrButton() {
        keyOrButtonUsed = true;
        resetIdleTimer();
    }

    // ─── Chapter crossing: logo pulse ───
    function onChapterAdvance() {
        resetIdleTimer();
        const brand = document.getElementById('brandLogo');
        if (brand) {
            brand.classList.add('chapter-pulse');
            setTimeout(() => brand.classList.remove('chapter-pulse'), 1800);
        }
    }

    // ─── Bracket nudge ───
    // Fires after 15+ sentences with zero brackets opened
    let bracketNudgeSent = false;
    function checkBracketNudge() {
        if (bracketNudgeSent || Toast.hasShown('bracket-nudge')) return;
        if (state.bracketsOpened === 0 && state.sentencesSeen.size >= 15) {
            bracketNudgeSent = true;
            setRailDot(true);
            Toast.show({
                id: 'bracket-nudge',
                icon: '[ ]',
                message: 'See the <span class="toast-accent">bracketed annotations</span>? Tap or click them to expand footnotes.',
                duration: 12000,
                onDismiss: () => setRailDot(false)
            });
        }
    }

    function onBracketOpened() {
        resetIdleTimer();
        bracketNudgeSent = true; // suppress nudge once they've used one
    }

    // ─── End-of-content CTA ───
    function onLastSentence() {
        if (Toast.hasShown('end-cta')) return;
        setRailDot(true);
        Toast.show({
            id: 'end-cta',
            icon: '✦',
            message: 'You\'ve reached the end of the plot.',
            actionLabel: 'Clear the Plot',
            actionFn: () => clearThePlot(),
            duration: 0,
            banner: true,
            onDismiss: () => setRailDot(false)
        });
    }

    function onSentenceAdvance() {
        resetIdleTimer();
        checkBracketNudge();
    }

    function onConclusionChapter() { /* removed — replaced by end-of-content CTA */ }

    function init() {
        // Welcome banner — always shows on page load, cycles through unique hints per session visit
        const WELCOME_POOL = [
            { id: 'welcome-banner-0', message: '<span class="toast-accent">Take time</span>. Move yourself & all will follow.' },
            { id: 'welcome-banner-1', message: 'Press <span class="toast-accent">H</span> to hide the interface — just you and the words.' }
        ];
        document.body.classList.add('ui-concealed');
        setTimeout(() => {
            const unshown = WELCOME_POOL.filter(w => !Toast.hasShown(w.id));
            const pick = unshown.length > 0 ? unshown[0] : WELCOME_POOL[0];
            Toast.show({ id: pick.id, icon: '✦', message: pick.message, duration: 12000, banner: true,
                force: unshown.length === 0, onDismiss: () => {} });
            setTimeout(() => { document.body.classList.remove('ui-concealed'); }, 9000);
        }, 1800);

        // Start idle detection
        idleTimer = setTimeout(onIdle, IDLE_THRESHOLD);

        // Ambient pool after 30s
        setTimeout(scheduleNextAmbient, 180000);
    }

    return { onWheel, onSingleWheel, onKeyOrButton, onSentenceAdvance, onChapterAdvance, onBracketOpened, onConclusionChapter, onLastSentence, init, getAmbientPool: () => AMBIENT_POOL, clearAmbientTimer: () => clearTimeout(ambientTimer), setRailDot };
})();

function makeDraggable(el, { useRight = true, useBottom = true } = {}) {
    if (!el || el.dataset.draggableBound) return;
    el.dataset.draggableBound = 'true';

    let isDragging = false;
    let hasMoved = false;
    let startX, startY, initialA, initialB;
    const DRAG_THRESHOLD = 4;

    function getInitialPos() {
        const style = window.getComputedStyle(el);
        initialA = useRight ? parseInt(style.right, 10) || 0 : parseInt(style.left, 10) || 0;
        initialB = useBottom ? parseInt(style.bottom, 10) || 0 : parseInt(style.top, 10) || 0;
    }

    function clampToViewport(aVal, bVal, w, h) {
        const rect = el.getBoundingClientRect();
        const elW = rect.width || 200;
        const elH = rect.height || 100;
        const margin = 8;
        if (useRight) {
            aVal = Math.max(margin, Math.min(aVal, w - elW - margin));
        } else {
            aVal = Math.max(margin, Math.min(aVal, w - elW - margin));
        }
        if (useBottom) {
            bVal = Math.max(margin, Math.min(bVal, h - elH - margin));
        } else {
            bVal = Math.max(margin, Math.min(bVal, h - elH - margin));
        }
        return [aVal, bVal];
    }

    function applyPos(aVal, bVal) {
        const [ca, cb] = clampToViewport(aVal, bVal, window.innerWidth, window.innerHeight);
        if (useRight) el.style.right = ca + 'px'; else el.style.left = ca + 'px';
        if (useBottom) el.style.bottom = cb + 'px'; else el.style.top = cb + 'px';
    }

    // Mouse
    el.addEventListener('mousedown', (e) => {
        if (window.innerWidth <= 768) return; // Disable drag on mobile
        if (e.target.closest('.k-key, .chapter-item, .chapter-dropdown-list, button, a, input, [role="button"]')) return;
        isDragging = true;
        hasMoved = false;
        el.style.cursor = 'grabbing';
        startX = e.clientX; startY = e.clientY;
        getInitialPos();
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dX = useRight ? startX - e.clientX : e.clientX - startX;
        const dY = useBottom ? startY - e.clientY : e.clientY - startY;
        if (!hasMoved && Math.abs(e.clientX - startX) < DRAG_THRESHOLD && Math.abs(e.clientY - startY) < DRAG_THRESHOLD) return;
        hasMoved = true;
        applyPos(initialA + dX, initialB + dY);
    });

    document.addEventListener('mouseup', (e) => {
        if (isDragging) {
            isDragging = false;
            hasMoved = false;
            el.style.cursor = '';
        }
    });

    // Touch
    let tStartX, tStartY;
    el.addEventListener('touchstart', (e) => {
        if (window.innerWidth <= 768) return; // Disable drag on mobile
        if (e.target.closest('.k-key, .chapter-item, .chapter-dropdown-list, button, a, input, [role="button"]')) return;
        isDragging = true;
        hasMoved = false;
        const t = e.touches[0];
        tStartX = t.clientX; tStartY = t.clientY;
        getInitialPos();
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const t = e.touches[0];
        if (!hasMoved && Math.abs(t.clientX - tStartX) < DRAG_THRESHOLD && Math.abs(t.clientY - tStartY) < DRAG_THRESHOLD) return;
        hasMoved = true;
        if (e.cancelable) e.preventDefault();
        const dX = useRight ? tStartX - t.clientX : t.clientX - tStartX;
        const dY = useBottom ? tStartY - t.clientY : t.clientY - tStartY;
        applyPos(initialA + dX, initialB + dY);
    }, { passive: false });

    document.addEventListener('touchend', () => { isDragging = false; hasMoved = false; });
}

// ===================================
// DRAGGABLE CHAPTER DROPDOWN
// ===================================
function initializeDraggableDropdown() {
    const dropdown = document.getElementById('chapterDropdown');
    const header = document.getElementById('chapterDropdownHeader');
    if (!dropdown || !header) return;

    let isDragging = false;
    let startX, startY, initLeft, initTop;

    // Canonical pixel position — null means "use CSS default"
    let pinnedLeft = null;
    let pinnedTop = null;

    function applyPinnedPosition() {
        if (pinnedLeft !== null && pinnedTop !== null) {
            dropdown.style.left = pinnedLeft + 'px';
            dropdown.style.top  = pinnedTop  + 'px';
        }
    }

    function clampDropdown(left, top) {
        const w = dropdown.offsetWidth  || 260;
        const h = dropdown.offsetHeight || 300;
        const margin = 8;
        left = Math.max(margin, Math.min(left, window.innerWidth  - w - margin));
        top  = Math.max(margin, Math.min(top,  window.innerHeight - h - margin));
        return [left, top];
    }

    function startDrag(clientX, clientY) {
        // Snapshot current rendered position into pixels on first drag
        if (pinnedLeft === null) {
            const rect = dropdown.getBoundingClientRect();
            pinnedLeft = rect.left;
            pinnedTop  = rect.top;
            dropdown.style.left = pinnedLeft + 'px';
            dropdown.style.top  = pinnedTop  + 'px';
        }
        isDragging = true;
        dropdown.classList.add('dragging');
        startX = clientX; startY = clientY;
        initLeft = pinnedLeft;
        initTop  = pinnedTop;
    }

    function moveDrag(clientX, clientY) {
        if (!isDragging) return;
        const [cl, ct] = clampDropdown(
            initLeft + (clientX - startX),
            initTop  + (clientY - startY)
        );
        pinnedLeft = cl;
        pinnedTop  = ct;
        dropdown.style.left = cl + 'px';
        dropdown.style.top  = ct + 'px';
    }

    function endDrag() {
        if (!isDragging) return;
        isDragging = false;
        dropdown.classList.remove('dragging');
    }

    // Apply pinned position every time the dropdown opens
    dropdown.addEventListener('transitionend', () => {
        if (dropdown.classList.contains('open')) applyPinnedPosition();
    });
    // Also apply immediately on open in case transition is skipped
    const observer = new MutationObserver(() => {
        if (dropdown.classList.contains('open')) applyPinnedPosition();
    });
    observer.observe(dropdown, { attributes: true, attributeFilter: ['class'] });

    // Mouse
    header.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        startDrag(e.clientX, e.clientY);
    });
    document.addEventListener('mousemove', (e) => { if (isDragging) moveDrag(e.clientX, e.clientY); });
    document.addEventListener('mouseup', endDrag);

    // Touch
    header.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const t = e.touches[0];
        startDrag(t.clientX, t.clientY);
    }, { passive: false });
    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        if (e.cancelable) e.preventDefault();
        const t = e.touches[0];
        moveDrag(t.clientX, t.clientY);
    }, { passive: false });
    document.addEventListener('touchend', endDrag);
}

// ===================================
// TOUCH DETECTION
// ===================================
function detectTouch() {
    window.addEventListener('touchstart', () => { state.lastInteractionWasTouch = true; state.isTouch = true; }, { passive: true });
    window.addEventListener('mousedown', () => { state.lastInteractionWasTouch = false; state.isTouch = false; }, { passive: true });
}

// ===================================
// NARRATIVE PARSING
// ===================================
function parseNarrative(text) {
    // ── Marker legend ──
    // ###:Title  → chapter break (must be on its own line or sentence boundary)
    // ##:Title   → subchapter break
    // #:         → line break (single blank line; any text after colon is first sentence of next line)
    // [ … ]      → bracket aside
    // /          → allowed freely in prose (no special meaning)

    const parts = [];
    let idCounter = 0;
    const segments = text.split(/(\[|\])/);
    let inBracket = false;
    let bracketId = null;

    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        if (segment === '[') {
            inBracket = true;
            bracketId = idCounter++;
            parts.push({ type: 'bracket', id: bracketId, content: '' });
        } else if (segment === ']') {
            inBracket = false;
            bracketId = null;
        } else if (segment.length > 0) {
            if (inBracket && bracketId !== null) {
                const bracket = parts.find(p => p.id === bracketId);
                if (bracket) bracket.content = segment.trim();
            } else {
                // Split on #: markers — capture the delimiter so we can classify each chunk
                // Order matters: ###: before ##: before >>: before #:
                const lineSegments = segment.split(/(###:[^\n]*|##:[^\n]*|>>:[^\n]*|#:)/);
                for (let j = 0; j < lineSegments.length; j++) {
                    const lineSegment = lineSegments[j];
                    if (!lineSegment) continue;

                    if (lineSegment.startsWith('###:')) {
                        // Chapter break — title follows the colon
                        const title = lineSegment.substring(4).trim();
                        if (title) parts.push({ type: 'chapter-marker', id: idCounter++, title });
                        continue;
                    }
                    if (lineSegment.startsWith('##:')) {
                        const title = lineSegment.substring(3).trim();
                        parts.push({ type: 'subchapter-break', id: idCounter++, title: title || '' });
                        continue;
                    }
                    if (lineSegment.startsWith('>>:')) {
                        // Pull-quote interjection — format: >>:Voice|Quote text
                        // or >>:Quote text (voice defaults to "Wolfie")
                        const raw = lineSegment.substring(3).trim();
                        const pipeIdx = raw.indexOf('|');
                        let voice, quote;
                        if (pipeIdx !== -1) {
                            voice = raw.substring(0, pipeIdx).trim();
                            quote = raw.substring(pipeIdx + 1).trim();
                        } else {
                            voice = 'Wolfie';
                            quote = raw;
                        }
                        if (quote) parts.push({ type: 'pullquote', id: idCounter++, voice, quote });
                        continue;
                    }
                    if (lineSegment === '#:') {
                        parts.push({ type: 'line-break', id: idCounter++, breakType: 'single' });
                        continue;
                    }

                    // Plain prose — split into sentences
                    if (lineSegment.trim()) {
                        const sentences = lineSegment.split(/(?<=[.!?])\s+/);
                        sentences.forEach(sentence => {
                            const trimmedSentence = sentence.trim();
                            if (!trimmedSentence) return;
                            if (/^\(\d+\)\s/.test(trimmedSentence)) {
                                const match = trimmedSentence.match(/^\((\d+)\)\s(.+)/);
                                if (match) { parts.push({ type: 'numbered-bullet', id: idCounter++, number: match[1], text: match[2].trim() }); return; }
                            }
                            if (trimmedSentence.startsWith('* ')) {
                                parts.push({ type: 'bullet', id: idCounter++, text: trimmedSentence.substring(2).trim() });
                                return;
                            }
                            parts.push({ type: 'sentence', id: idCounter++, text: trimmedSentence });
                        });
                    }
                }
            }
        }
    }
    return parts;
}

// ===================================
// IMAGE HANDLING
// ===================================
function htmlAttrEncode(s) {
    return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function applyInlineMarkdown(text) {
    // Order matters: bold before italic to avoid partial matches
    return text
        .replace(/~~(.*?)~~/g, '<s>$1</s>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
}

function wrapImageTriggers(text) {
    let wrapped = applyInlineMarkdown(text);
    for (const [phrase, url] of Object.entries(imageMap)) {
        const regex = phraseRegexMap.get(phrase);
        if (regex) {
            const safeUrl   = htmlAttrEncode(url);
            const safeLabel = htmlAttrEncode(phrase);
            wrapped = wrapped.replace(regex,
                `<button class="image-trigger" data-image="${safeUrl}" aria-label="View image: ${safeLabel}" type="button">$&</button>`
            );
        }
    }
    return wrapped;
}

function preloadImages() {
    const urls = [...new Set(Object.values(imageMap))];
    urls.forEach(url => {
        if (!url.match(/\.mp4(\?|$)/i)) { const img = new Image(); img.src = url; }
    });
}

function isVideo(url) { return url && url.match(/\.mp4(\?|$)/i); }

function showImage(imageUrl, triggerElement) {
    cursor.currentImageElement = triggerElement;
    state.imageActive = true;
    state.currentTriggerRect = triggerElement.getBoundingClientRect();
    document.body.classList.add('image-active');

    const isReadMode = document.body.classList.contains('focus-mode');

    if (isReadMode) {
        const thumb = Utils.$('#cursor-thumb');
        if (state.imageTimeout) clearTimeout(state.imageTimeout);
        state.imageTimeout = setTimeout(() => {
            if (isVideo(imageUrl)) {
                // For video in focus mode: show in hover panel instead of cursor thumb
                const hoverImage = Utils.$('#hoverImage');
                const hoverImageImg = Utils.$('#hoverImageImg');
                const hoverImageVideo = Utils.$('#hoverImageVideo');
                hoverImageImg.style.display = 'none';
                hoverImageVideo.style.display = 'block';
                hoverImageVideo.src = imageUrl;
                hoverImageVideo.load();
                hoverImageVideo.play().catch(() => {});
                hoverImage.classList.add('active');
            } else {
                thumb.onload = () => cursor.element.classList.add('thumb-active');
                thumb.onerror = () => cursor.element.classList.add('thumb-active');
                if (thumb.src !== imageUrl) thumb.src = imageUrl;
                else cursor.element.classList.add('thumb-active');
            }
        }, CONFIG.IMAGE_HOVER_DELAY);
    } else {
        const hoverImage = Utils.$('#hoverImage');
        const hoverImageImg = Utils.$('#hoverImageImg');
        const hoverImageVideo = Utils.$('#hoverImageVideo');
        if (state.imageTimeout) clearTimeout(state.imageTimeout);
        state.imageTimeout = setTimeout(() => {
            if (isVideo(imageUrl)) {
                hoverImageImg.style.display = 'none';
                hoverImageVideo.style.display = 'block';
                hoverImageVideo.src = imageUrl;
                hoverImageVideo.load();
                hoverImageVideo.play().catch(() => {});
                hoverImage.classList.add('active');
            } else {
                hoverImageImg.style.display = 'block';
                hoverImageVideo.style.display = 'none';
                hoverImageVideo.pause();
                hoverImageVideo.src = '';
                hoverImageImg.onload = () => hoverImage.classList.add('active');
                hoverImageImg.onerror = () => hoverImage.classList.add('active');
                hoverImageImg.src = imageUrl;
            }
        }, CONFIG.IMAGE_HOVER_DELAY);
    }
}

function hideImage() {
    const hoverImage = Utils.$('#hoverImage');
    const hoverImageVideo = Utils.$('#hoverImageVideo');
    if (state.imageTimeout) clearTimeout(state.imageTimeout);
    hoverImage.classList.remove('active');
    if (hoverImageVideo) { hoverImageVideo.pause(); hoverImageVideo.src = ''; hoverImageVideo.style.display = 'none'; }
    const hoverImageImg = Utils.$('#hoverImageImg');
    if (hoverImageImg) hoverImageImg.style.display = 'block';
    cursor.element.classList.remove('has-image', 'thumb-active');
    document.body.classList.remove('image-active');
    state.imageActive = false;
    cursor.currentImageElement = null;
    state.currentTriggerRect = null;
}

// ===================================
// CHAPTER MANAGEMENT
// ===================================
function getCurrentChapter() {
    if (state.allSentenceElements.length === 0) return 0;
    for (let i = chapters.length - 1; i >= 0; i--) {
        if (state.currentSentenceIndex >= state.chapterStartIndices[i]) return i;
    }
    return 0;
}

function goToChapter(chapterId) {
    const startIndex = state.chapterStartIndices[chapterId];
    if (startIndex !== undefined && startIndex >= 0) {
        state.currentSentenceIndex = startIndex;
        highlightSentence(startIndex);
        closeChapterDropdown();
    }
}

function getStops() {
    const chapterStops = state.chapterStartIndices
        .filter(idx => idx >= 0)
        .map((sentenceIndex, i) => ({ sentenceIndex, type: 'chapter', id: i }));
    const subchapterStops = state.subchapterStartIndices
        .map(s => ({ sentenceIndex: s.sentenceIndex, type: 'subchapter', title: s.title }));
    return [...chapterStops, ...subchapterStops].sort((a, b) => a.sentenceIndex - b.sentenceIndex);
}

function nextChapter() {
    const cur = state.currentSentenceIndex;
    const stops = getStops();
    const next = stops.find(s => s.sentenceIndex > cur);
    if (next) { state.currentSentenceIndex = next.sentenceIndex; highlightSentence(next.sentenceIndex); }
}

function previousChapter() {
    const cur = state.currentSentenceIndex;
    const stops = getStops();
    const prev = [...stops].reverse().find(s => s.sentenceIndex < cur);
    if (prev) { state.currentSentenceIndex = prev.sentenceIndex; highlightSentence(prev.sentenceIndex); }
}

// ===================================
// SENTENCE NAVIGATION
// ===================================
function nextSentence() {
    if (state.allSentenceElements.length === 0) return;
    state.currentSentenceIndex = (state.currentSentenceIndex + 1) % state.allSentenceElements.length;
    highlightSentence(state.currentSentenceIndex, 1);
}

function previousSentence() {
    if (state.allSentenceElements.length === 0) return;
    state.currentSentenceIndex = (state.currentSentenceIndex - 1 + state.allSentenceElements.length) % state.allSentenceElements.length;
    highlightSentence(state.currentSentenceIndex, -1);
}

function highlightSentence(index, dir = 1) {
    const sentence = state.allSentenceElements[index];
    if (!sentence) return;

    // Auto-advance past structural elements (chapter/section breaks) during reader navigation
    if (sentence.dataset.structural && !composeActive) {
        const next = index + dir;
        if (next >= 0 && next < state.allSentenceElements.length) {
            state.currentSentenceIndex = next;
            highlightSentence(next, dir);
            return;
        }
    }

    state.allSentenceElements.forEach(s => {
        s.classList.remove('active');
        s.classList.add('dimmed');
        s.style.opacity = '';
        s.removeAttribute('aria-current');
    });
    sentence.classList.add('active');
    sentence.classList.remove('dimmed');
    sentence.setAttribute('aria-current', 'true');

    // Announce to screen readers
    const announcer = document.getElementById('srAnnouncer');
    if (announcer) {
        const text = sentence.textContent.trim();
        announcer.textContent = '';
        requestAnimationFrame(() => { announcer.textContent = text; });
    }

    // Move focus to sentence if navigating via keyboard (not mouse)
    if (state.lastNavWasKeyboard) sentence.focus({ preventScroll: true });

    // Track stats — skip structural elements
    if (!sentence.dataset.structural) {
        trackSentence(index);
        toastBehaviors.onSentenceAdvance();
        if (index === state.allSentenceElements.length - 1) toastBehaviors.onLastSentence();
    }
    trackChapter(getCurrentChapter());

    updateChapterProgress();
    updateChapterDropdown();
    sentence.scrollIntoView({ behavior: 'smooth', block: 'center' });
    const imageTrigger = sentence.querySelector('.image-trigger');
    if (imageTrigger) {
        const imageUrl = imageTrigger.getAttribute('data-image');
        if (imageUrl) showImage(imageUrl, imageTrigger);
    } else {
        hideImage();
    }
}

function resetToBeginning() {
    if (state.allSentenceElements.length === 0) return;
    state.currentSentenceIndex = 0;
    highlightSentence(0);
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// ===================================
// UI UPDATE FUNCTIONS
// ===================================
function updateChapterProgress() {
    const currentChapter = getCurrentChapter();
    const bars = Utils.$$('.chapter-bar');
    bars.forEach(bar => {
        const chapterId = parseInt(bar.dataset.chapterId);
        bar.classList.remove('active', 'completed');
        if (chapterId === currentChapter) bar.classList.add('active');
        else if (chapterId < currentChapter) bar.classList.add('completed');
    });
    const total = state.allSentenceElements.length;
    const current = state.currentSentenceIndex + 1;
    const progress = (current / total) * 100;
    // Landscape right-rail progress
    const landProgressFill = Utils.$('#landProgressFill');
    if (landProgressFill) landProgressFill.style.height = `${progress}%`;
}

function updateChapterDropdown() {
    const currentChapter = getCurrentChapter();
    const items = Utils.$$('.chapter-item');
    items.forEach(item => {
        const chapterId = parseInt(item.dataset.chapterId);
        if (chapterId === currentChapter) {
            item.classList.add('active');
            if (isDropdownOpen()) item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            item.classList.remove('active');
        }
    });
}

function initializeChapterProgress() {
    const container = Utils.$('#chapterProgressContainer');
    if (!container) return;
    container.innerHTML = '';
    let isRapidScrolling = false;
    let rapidScrollTimeout = null;
    chapters.forEach(chapter => {
        const bar = document.createElement('div');
        bar.className = 'chapter-bar';
        bar.dataset.chapterId = chapter.id;
        bar.dataset.chapterTitle = `${String(chapter.id + 1).padStart(2, '0')}. ${chapter.title}`;
        bar.title = chapter.title;
        bar.addEventListener('click', function(e) { e.stopPropagation(); goToChapter(parseInt(this.dataset.chapterId)); });
        bar.addEventListener('mouseenter', function() { if (isRapidScrolling) goToChapter(parseInt(this.dataset.chapterId)); });
        bar.addEventListener('mousedown', function(e) { e.preventDefault(); isRapidScrolling = true; if (rapidScrollTimeout) clearTimeout(rapidScrollTimeout); });
        container.appendChild(bar);
    });
    document.addEventListener('mouseup', function() {
        if (isRapidScrolling) {
            isRapidScrolling = false;
            if (rapidScrollTimeout) clearTimeout(rapidScrollTimeout);
            rapidScrollTimeout = setTimeout(() => isRapidScrolling = false, 100);
        }
    });
    updateChapterProgress();
}

function buildChapterDropdown() {
    const dropdownList = Utils.$('#chapterDropdownList');
    dropdownList.innerHTML = '';
    chapters.forEach(chapter => {
        const startIndex = state.chapterStartIndices[chapter.id];
        const endIndex = chapter.id < chapters.length - 1 ? state.chapterStartIndices[chapter.id + 1] : state.allSentenceElements.length;
        const li = document.createElement('li');
        li.className = 'chapter-item';
        li.dataset.chapterId = chapter.id;
        li.innerHTML = `
            <span class="chapter-item-number">${String(chapter.id + 1).padStart(2, '0')}</span>
            <span class="chapter-item-title">${chapter.title}</span>
            <span class="chapter-item-progress">${endIndex - startIndex} sentences</span>
        `;
        li.addEventListener('click', () => goToChapter(chapter.id));
        dropdownList.appendChild(li);
    });
}

// ===================================
// DROPDOWN MANAGEMENT
// ===================================
function isDropdownOpen() { return Utils.$('#chapterDropdown').classList.contains('open'); }

function toggleChapterDropdown() {
    const brand = Utils.$('#brandLogo');
    const dropdown = Utils.$('#chapterDropdown');
    brand.classList.toggle('open');
    dropdown.classList.toggle('open');
    if (dropdown.classList.contains('open')) updateChapterDropdown();
    // Clear any chapter-break opener when toggled via logo
    if (!dropdown.classList.contains('open')) clearChapterBreakOpener();
}

function clearChapterBreakOpener() {
    if (state.chapterBreakOpener) {
        state.chapterBreakOpener.classList.remove('dropdown-active');
        state.chapterBreakOpener = null;
    }
}

function closeChapterDropdown() {
    Utils.$('#brandLogo').classList.remove('open');
    Utils.$('#chapterDropdown').classList.remove('open');
    clearChapterBreakOpener();
}

function openDropdownFromChapterBreak(chapterBreakEl, chapterId) {
    const dropdown = Utils.$('#chapterDropdown');
    const brand = Utils.$('#brandLogo');

    // If already open from this exact chapter-break → close (toggle off)
    if (isDropdownOpen() && state.chapterBreakOpener === chapterBreakEl) {
        closeChapterDropdown();
        return;
    }

    // Clear previous opener highlight
    clearChapterBreakOpener();

    // Open dropdown
    brand.classList.add('open');
    dropdown.classList.add('open');
    updateChapterDropdown();

    // Mark this chapter-break as the opener
    state.chapterBreakOpener = chapterBreakEl;
    chapterBreakEl.classList.add('dropdown-active');

    // Scroll the matching chapter item into view inside the dropdown
    requestAnimationFrame(() => {
        const item = dropdown.querySelector(`.chapter-item[data-chapter-id="${chapterId}"]`);
        if (item) item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    });
}

// ===================================
// IMAGE GRID
// ===================================
function isGridOpen() { return Utils.$('#imageGridOverlay').classList.contains('open'); }

function toggleImageGrid() {
    const overlay = Utils.$('#imageGridOverlay');
    const btns = Utils.$$('.grid-toggle-btn');
    if (overlay.classList.contains('open')) {
        overlay.classList.remove('open');
        document.body.classList.remove('grid-open');
        document.body.style.overflow = '';
        btns.forEach(btn => btn.querySelector('span:last-child').textContent = '▦');
    } else {
        overlay.classList.add('open');
        document.body.classList.add('grid-open');
        document.body.style.overflow = 'hidden';
        btns.forEach(btn => btn.querySelector('span:last-child').textContent = '✕');
        buildImageGrid();
    }
}

function buildImageGrid() {
    const content = Utils.$('#gridContent');
    content.innerHTML = '';
    const imagesByChapter = {};
    state.gridImages.forEach(imgData => {
        if (!imagesByChapter[imgData.chapterId]) imagesByChapter[imgData.chapterId] = [];
        imagesByChapter[imgData.chapterId].push(imgData);
    });
    chapters.forEach(chapter => {
        if (imagesByChapter[chapter.id] && imagesByChapter[chapter.id].length > 0) {
            const section = document.createElement('div');
            section.className = 'grid-chapter-section';
            section.innerHTML = `<div class="grid-chapter-title">Chapter ${String(chapter.id + 1).padStart(2, '0')} · ${chapter.title}</div>`;
            const grid = document.createElement('div');
            grid.className = 'grid-images-container';
            imagesByChapter[chapter.id].forEach(imgData => {
                const item = document.createElement('div');
                item.className = 'grid-image-item';
                const isVid = imgData.url.match(/\.mp4(\?|$)/i);
                const mediaEl = isVid
                    ? `<video src="${imgData.url}" muted autoplay loop playsinline preload="metadata" style="width:100%;height:100%;object-fit:cover;opacity:0.85;transition:opacity 0.25s ease;display:block;"></video>`
                    : `<img src="${imgData.url}" loading="lazy" alt="${imgData.text.replace(/"/g, '&quot;')}">`;

                // Delete button (hidden until hover)
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'grid-item-delete';
                deleteBtn.textContent = 'Delete';
                deleteBtn.title = 'Remove this image';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!confirm(`Remove image from grid?`)) return;
                    // Remove from state
                    const idx = state.gridImages.indexOf(imgData);
                    if (idx > -1) state.gridImages.splice(idx, 1);
                    // Clear image from the associated sentence element
                    const sentenceEl = state.allSentenceElements[imgData.index];
                    if (sentenceEl) {
                        delete sentenceEl.dataset.imageUrl;
                        const img = sentenceEl.querySelector('.hover-image');
                        if (img) img.remove();
                    }
                    buildImageGrid();
                });

                // Caption inline edit
                const caption = document.createElement('div');
                caption.className = 'grid-image-caption';
                const captionInput = document.createElement('textarea');
                captionInput.className = 'grid-inline-input';
                captionInput.value = imgData.text || '';
                captionInput.placeholder = 'Caption…';
                captionInput.rows = 2;
                captionInput.addEventListener('click', (e) => e.stopPropagation());
                captionInput.addEventListener('change', (e) => {
                    imgData.text = e.target.value;
                    // update caption text in associated sentence too
                    const sentenceEl = state.allSentenceElements[imgData.index];
                    if (sentenceEl) sentenceEl.dataset.imageCaption = e.target.value;
                });
                caption.appendChild(captionInput);

                item.innerHTML = mediaEl;
                item.appendChild(deleteBtn);
                item.appendChild(caption);
                item.addEventListener('click', () => { toggleImageGrid(); state.currentSentenceIndex = imgData.index; highlightSentence(imgData.index); });
                grid.appendChild(item);
            });
            section.appendChild(grid);
            content.appendChild(section);
        }
    });
}

// ===================================
// SCROLL & TOUCH HANDLING
// ===================================
function handleScroll(event) {
    if (state.scrollCooldownActive) return;
    if (event.target.closest('.chapter-dropdown-list, .image-grid-overlay')) return;
    if (isDropdownOpen()) { event.preventDefault(); return; }
    if (isGridOpen()) return;
    const scrollDelta = event.deltaY;
    if (Math.abs(scrollDelta) >= CONFIG.SCROLL_THRESHOLD) {
        state.scrollCooldownActive = true;
        if (scrollDelta > 0) nextSentence(); else previousSentence();
        setTimeout(() => { state.scrollCooldownActive = false; }, CONFIG.SCROLL_COOLDOWN);
    }
    event.preventDefault();
}

function handleTouchStart(e) { state.touchStartY = e.touches[0].clientY; state.touchStartX = e.touches[0].clientX; state.touchMoved = false; }
function handleTouchMove(e) {
    state.touchMoved = true;
    if (e.target.closest('.chapter-dropdown-list, .image-grid-overlay')) return;
    if (isDropdownOpen()) { e.preventDefault(); return; }
    if (isGridOpen()) return;
    e.preventDefault();
}
function handleTouchEnd(e) {
    if (!state.touchMoved || state.scrollCooldownActive || isDropdownOpen() || isGridOpen()) return;
    const touchEndY = e.changedTouches[0].clientY;
    const deltaY = state.touchStartY - touchEndY;
    if (Math.abs(deltaY) > CONFIG.FLICK_THRESHOLD) {
        state.scrollCooldownActive = true;
        if (deltaY > 0) nextSentence(); else previousSentence();
        setTimeout(() => { state.scrollCooldownActive = false; }, CONFIG.SCROLL_COOLDOWN);
    }
}

// ===================================
// PARALLAX & CURSOR
// ===================================
function updateParallax() {
    const viewportCenterX = window.innerWidth / 2;
    const viewportCenterY = window.innerHeight / 2;
    const mouseOffsetX = (state.mouseX - viewportCenterX) / viewportCenterX;
    const mouseOffsetY = (state.mouseY - viewportCenterY) / viewportCenterY;
    parallax.text.targetX = mouseOffsetX * 20 * CONFIG.TEXT_PARALLAX_STRENGTH;
    parallax.text.targetY = mouseOffsetY * 20 * CONFIG.TEXT_PARALLAX_STRENGTH;
    if (state.imageActive && state.currentTriggerRect) {
        const trigger = state.currentTriggerRect;
        const triggerCenterX = trigger.left + trigger.width / 2;
        const triggerCenterY = trigger.top + trigger.height / 2;
        const distToCenterX = (viewportCenterX - triggerCenterX) / viewportCenterX;
        const distToCenterY = (viewportCenterY - triggerCenterY) / viewportCenterY;
        parallax.image.targetX = (mouseOffsetX * 100 * CONFIG.IMAGE_PARALLAX_STRENGTH) - (distToCenterX * CONFIG.CENTER_MAGNET_STRENGTH * 100);
        parallax.image.targetY = (mouseOffsetY * 100 * CONFIG.IMAGE_PARALLAX_STRENGTH) - (distToCenterY * CONFIG.CENTER_MAGNET_STRENGTH * 100);
    } else {
        parallax.image.targetX = 0; parallax.image.targetY = 0;
    }
    parallax.text.x += (parallax.text.targetX - parallax.text.x) * CONFIG.PARALLAX_DAMPING;
    parallax.text.y += (parallax.text.targetY - parallax.text.y) * CONFIG.PARALLAX_DAMPING;
    parallax.image.x += (parallax.image.targetX - parallax.image.x) * CONFIG.PARALLAX_DAMPING;
    parallax.image.y += (parallax.image.targetY - parallax.image.y) * CONFIG.PARALLAX_DAMPING;
    const textLayer = Utils.$('#textLayer');
    const imageLayer = Utils.$('#imageLayer');
    const gridOverlay = Utils.$('#gridContent');
    const wireframeBg = Utils.$('#gridWireframeBg');
    if (textLayer) textLayer.style.transform = `translate3d(${parallax.text.x}px, ${parallax.text.y}px, 0)`;
    if (imageLayer) imageLayer.style.transform = `translate3d(${parallax.image.x}px, ${parallax.image.y}px, 0)`;
    if (gridOverlay) gridOverlay.style.transform = `translate3d(${parallax.image.x * 0.5}px, ${parallax.image.y * 0.5}px, 0)`;
    // Wireframe parallax: moves opposite/slower for depth cue
    if (wireframeBg) {
        wireframeBg.style.transform = `translate3d(${parallax.image.x * -0.18}px, ${parallax.image.y * -0.18}px, 0)`;
        // Zoom visibility check
        const scale = window.visualViewport ? window.visualViewport.scale : 1;
        wireframeBg.classList.toggle('visible', scale >= 0.75 && document.body.classList.contains('grid-open'));
    }
    requestAnimationFrame(updateParallax);
}

function updateCursor() {
    if (!cursor.element) return;
    cursor.x += (cursor.targetX - cursor.x) * CONFIG.CURSOR_SMOOTHING;
    cursor.y += (cursor.targetY - cursor.y) * CONFIG.CURSOR_SMOOTHING;
    cursor.element.style.transform = `translate3d(${cursor.x}px, ${cursor.y}px, 0) translate(-50%, -50%)`;
    requestAnimationFrame(updateCursor);
}

// ===================================
// RENDER FUNCTION
// ===================================
function render() {
    const streamEl = Utils.$('#stream');
    const parsedContent = parseNarrative(narrative);
    const fragment = document.createDocumentFragment();
    state.allSentenceElements = [];
    state.gridImages = [];
    state.chapterStartIndices = new Array(chapters.length).fill(-1);
    state.subchapterStartIndices = [];
    chapters.forEach(chapter => {
        const index = narrative.indexOf(chapter.startText);
        if (index !== -1) state.chapterStartIndices[chapter.id] = index;
    });
    let sentenceCount = 0;
    let nextChapterIndex = 0;
    let currentActiveChapter = 0;

    parsedContent.forEach(part => {
        // ── Legacy startText-based chapter detection (for chapters[] array entries) ──
        if (nextChapterIndex < chapters.length) {
            const nextChapter = chapters[nextChapterIndex];
            if (nextChapter.startText) {
                const textContent = part.type === 'sentence' || part.type === 'bullet' || part.type === 'numbered-bullet' ? part.text : (part.type === 'bracket' ? part.content : '');
                if (textContent && textContent.includes(nextChapter.startText)) {
                    state.chapterStartIndices[nextChapter.id] = sentenceCount;
                    const chapterBreak = document.createElement('div');
                    chapterBreak.className = 'chapter-break';
                    chapterBreak.dataset.chapterId = nextChapter.id;
                    chapterBreak.dataset.type = 'chapter';
                    chapterBreak.dataset.structural = 'true';
                    chapterBreak.dataset.sentenceIndex = sentenceCount;
                    chapterBreak.dataset.title = nextChapter.title;
                    chapterBreak.innerHTML = `<span class="chapter-number">Chapter ${String(nextChapter.id + 1).padStart(2, '0')}</span><span class="chapter-title">${nextChapter.title}</span>`;
                    chapterBreak.addEventListener('click', () => { showUI(); openDropdownFromChapterBreak(chapterBreak, nextChapter.id); });
                    chapterBreak.addEventListener('dblclick', () => { if (!composeActive) return; beginEdit(parseInt(chapterBreak.dataset.sentenceIndex)); });
                    fragment.appendChild(chapterBreak);
                    state.allSentenceElements.push(chapterBreak);
                    sentenceCount++;
                    currentActiveChapter = nextChapter.id;
                    nextChapterIndex++;
                }
            }
        }

        // ── ###: inline chapter marker ──
        if (part.type === 'chapter-marker') {
            const newChapterId = chapters.length;
            chapters.push({ id: newChapterId, title: part.title, startText: null });
            state.chapterStartIndices.push(sentenceCount);
            const chapterBreak = document.createElement('div');
            chapterBreak.className = 'chapter-break';
            chapterBreak.dataset.chapterId = newChapterId;
            chapterBreak.dataset.type = 'chapter';
            chapterBreak.dataset.structural = 'true';
            chapterBreak.dataset.sentenceIndex = sentenceCount;
            chapterBreak.dataset.title = part.title;
            chapterBreak.innerHTML = `<span class="chapter-number">Chapter ${String(newChapterId + 1).padStart(2, '0')}</span><span class="chapter-title">${part.title}</span>`;
            chapterBreak.addEventListener('click', () => { showUI(); openDropdownFromChapterBreak(chapterBreak, newChapterId); });
            chapterBreak.addEventListener('dblclick', () => {
                if (!composeActive) return;
                beginEdit(parseInt(chapterBreak.dataset.sentenceIndex));
            });
            fragment.appendChild(chapterBreak);
            state.allSentenceElements.push(chapterBreak);
            sentenceCount++;
            currentActiveChapter = newChapterId;
            return;
        }

        if (part.type === 'sentence') {
            const span = document.createElement('span');
            span.className = 'sentence';
            span.dataset.sentenceIndex = sentenceCount;
            span.style.cursor = 'pointer';
            span.setAttribute('tabindex', '0');
            span.setAttribute('role', 'button');
            span.setAttribute('aria-label', `Sentence ${sentenceCount + 1}: ${part.text.replace(/<[^>]+>/g, '')}`);
            for (const [phrase, url] of Object.entries(imageMap)) {
                if (part.text.includes(phrase)) { state.gridImages.push({ index: sentenceCount, text: part.text, url: url, chapterId: currentActiveChapter }); break; }
            }
            span.innerHTML = wrapImageTriggers(part.text) + ' ';
            span.addEventListener('mouseenter', () => { if (state.isTouch) return; const index = parseInt(span.dataset.sentenceIndex); state.allSentenceElements.forEach((s, i) => { s.style.opacity = i === index ? '0.7' : '0.25'; }); }, { passive: true });
            span.addEventListener('mouseleave', () => { if (state.isTouch) return; state.allSentenceElements.forEach(s => s.style.opacity = ''); }, { passive: true });
            span.addEventListener('click', () => { state.currentSentenceIndex = parseInt(span.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); });
            span.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); state.currentSentenceIndex = parseInt(span.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); }
            });
            state.allSentenceElements.push(span);
            sentenceCount++;
            fragment.appendChild(span);
        } else if (part.type === 'line-break') {
            const br = document.createElement('span');
            br.className = 'line-break-spacer';
            br.innerHTML = part.breakType === 'double' ? '<br><br>' : '<br>';
            fragment.appendChild(br);
        } else if (part.type === 'subchapter-break') {
            const el = document.createElement('div');
            el.className = 'subchapter-break';
            el.dataset.type = 'section';
            el.dataset.structural = 'true';
            el.dataset.sentenceIndex = sentenceCount;
            el.dataset.title = part.title;
            el.innerHTML = `<span class="subchapter-title">${part.title}</span>`;
            el.addEventListener('dblclick', () => {
                if (!composeActive) return;
                beginEdit(parseInt(el.dataset.sentenceIndex));
            });
            state.subchapterStartIndices.push({ sentenceIndex: sentenceCount, title: part.title });
            state.allSentenceElements.push(el);
            sentenceCount++;
            fragment.appendChild(el);
        } else if (part.type === 'pullquote') {
            const el = document.createElement('div');
            el.className = 'pullquote-break';
            el.dataset.type = 'pullquote';
            el.dataset.structural = 'true';
            el.dataset.sentenceIndex = sentenceCount;
            el.dataset.voice = part.voice;
            el.innerHTML = `<span class="pullquote-voice">${part.voice}</span><span class="pullquote-text">${applyInlineMarkdown(part.quote)}</span>`;
            el.addEventListener('dblclick', () => {
                if (!composeActive) return;
                beginEdit(parseInt(el.dataset.sentenceIndex));
            });
            state.allSentenceElements.push(el);
            sentenceCount++;
            fragment.appendChild(el);
        } else if (part.type === 'bullet') {
            const li = document.createElement('div');
            li.className = 'sentence bullet-item';
            li.dataset.sentenceIndex = sentenceCount;
            li.style.cursor = 'pointer';
            li.setAttribute('tabindex', '0');
            li.setAttribute('role', 'button');
            li.setAttribute('aria-label', `Sentence ${sentenceCount + 1}: ${part.text.replace(/<[^>]+>/g, '')}`);
            for (const [phrase, url] of Object.entries(imageMap)) {
                if (part.text.includes(phrase)) { state.gridImages.push({ index: sentenceCount, text: part.text, url: url, chapterId: currentActiveChapter }); break; }
            }
            li.innerHTML = '<span class="bullet-marker" aria-hidden="true">•</span> ' + wrapImageTriggers(part.text);
            li.addEventListener('mouseenter', () => { if (state.isTouch) return; const index = parseInt(li.dataset.sentenceIndex); state.allSentenceElements.forEach((s, i) => { s.style.opacity = i === index ? '0.7' : '0.25'; }); }, { passive: true });
            li.addEventListener('mouseleave', () => { if (state.isTouch) return; state.allSentenceElements.forEach(s => s.style.opacity = ''); }, { passive: true });
            li.addEventListener('click', () => { state.currentSentenceIndex = parseInt(li.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); });
            li.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); state.currentSentenceIndex = parseInt(li.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); }
            });
            state.allSentenceElements.push(li);
            sentenceCount++;
            fragment.appendChild(li);
        } else if (part.type === 'numbered-bullet') {
            const li = document.createElement('div');
            li.className = 'sentence numbered-bullet-item';
            li.dataset.sentenceIndex = sentenceCount;
            li.style.cursor = 'pointer';
            li.setAttribute('tabindex', '0');
            li.setAttribute('role', 'button');
            li.setAttribute('aria-label', `Sentence ${sentenceCount + 1}: ${part.text.replace(/<[^>]+>/g, '')}`);
            for (const [phrase, url] of Object.entries(imageMap)) {
                if (part.text.includes(phrase)) { state.gridImages.push({ index: sentenceCount, text: part.text, url: url, chapterId: currentActiveChapter }); break; }
            }
            li.innerHTML = `<span class="numbered-marker" aria-hidden="true">${part.number}.</span> ` + wrapImageTriggers(part.text);
            li.addEventListener('mouseenter', () => { if (state.isTouch) return; const index = parseInt(li.dataset.sentenceIndex); state.allSentenceElements.forEach((s, i) => { s.style.opacity = i === index ? '0.7' : '0.25'; }); }, { passive: true });
            li.addEventListener('mouseleave', () => { if (state.isTouch) return; state.allSentenceElements.forEach(s => s.style.opacity = ''); }, { passive: true });
            li.addEventListener('click', () => { state.currentSentenceIndex = parseInt(li.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); });
            li.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); state.currentSentenceIndex = parseInt(li.dataset.sentenceIndex); highlightSentence(state.currentSentenceIndex); }
            });
            state.allSentenceElements.push(li);
            sentenceCount++;
            fragment.appendChild(li);
        } else if (part.type === 'bracket') {
            const trigger = document.createElement('button');
            trigger.className = 'bracket-trigger';
            trigger.textContent = '[+]';
            const contentId = `bracket-content-${part.id}`;
            trigger.setAttribute('aria-controls', contentId);
            trigger.setAttribute('aria-expanded', 'false');
            trigger.setAttribute('aria-label', 'Expand annotation');
            const content = document.createElement('span');
            content.className = 'bracket-content';
            content.id = contentId;
            content.textContent = ' ' + part.content + ' ';
            trigger.addEventListener('click', () => {
                const isExpanded = content.classList.toggle('visible');
                trigger.textContent = isExpanded ? '[−]' : '[+]';
                trigger.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
                trigger.setAttribute('aria-label', isExpanded ? 'Collapse annotation' : 'Expand annotation');
                trigger.classList.toggle('expanded');
                if (isExpanded) {
                    // Close every other open bracket before opening this one
                    document.querySelectorAll('.bracket-content.visible').forEach(otherContent => {
                        if (otherContent === content) return;
                        otherContent.classList.remove('visible');
                        const otherId = parseInt(otherContent.id.replace('bracket-content-', ''));
                        state.expandedBrackets.delete(otherId);
                        const otherTrigger = document.querySelector(`[aria-controls="${otherContent.id}"]`);
                        if (otherTrigger) {
                            otherTrigger.textContent = '[+]';
                            otherTrigger.setAttribute('aria-expanded', 'false');
                            otherTrigger.setAttribute('aria-label', 'Expand annotation');
                            otherTrigger.classList.remove('expanded');
                        }
                    });
                    state.expandedBrackets.add(part.id);
                    trackBracketOpen();
                } else {
                    state.expandedBrackets.delete(part.id);
                }
                // Keep [ ] button in sync
                const allExpanded = [...document.querySelectorAll('.bracket-trigger')].every(t => t.classList.contains('expanded'));
                document.getElementById('modeKeyBrackets')?.classList.toggle('mode-active', allExpanded);
            });
            fragment.appendChild(trigger);
            fragment.appendChild(content);
        }
    });
    
    streamEl.innerHTML = '';
    streamEl.appendChild(fragment);
    buildChapterDropdown();
    initializeChapterProgress();
    
    streamEl.addEventListener('mouseover', e => {
        const trigger = e.target.closest('.image-trigger');
        if (trigger) { const imageUrl = trigger.getAttribute('data-image'); if (imageUrl) showImage(imageUrl, trigger); }
    }, { passive: true });
    streamEl.addEventListener('mouseout', e => { if (e.target.closest('.image-trigger')) hideImage(); }, { passive: true });

    // Keyboard and focus access for image triggers
    streamEl.addEventListener('focusin', e => {
        const trigger = e.target.closest('.image-trigger');
        if (trigger) { const imageUrl = trigger.getAttribute('data-image'); if (imageUrl) showImage(imageUrl, trigger); }
    }, { passive: true });
    streamEl.addEventListener('focusout', e => {
        if (e.target.closest('.image-trigger')) hideImage();
    }, { passive: true });
    streamEl.addEventListener('keydown', e => {
        const trigger = e.target.closest('.image-trigger');
        if (trigger && (e.key === 'Enter' || e.key === ' ')) {
            e.preventDefault();
            const imageUrl = trigger.getAttribute('data-image');
            if (imageUrl) showImage(imageUrl, trigger);
        }
        if (e.key === 'Escape' && state.imageActive) { e.preventDefault(); hideImage(); }
    });
}

// ===================================
// CONTEXT MENU
// ===================================
function initializeContextMenu() {
    // Suppress browser right-click context menu
    document.addEventListener('contextmenu', e => e.preventDefault());

    // Mobile: long press on stream → hide UI; any scroll gesture restores it
    const streamEl = Utils.$('#stream');
    if (streamEl) {
        let lpTimer = null;
        let lpMoved = false;
        streamEl.addEventListener('touchstart', (e) => {
            if (e.target.closest('.bracket-trigger, .image-trigger, .chapter-break, .subchapter-break, button, a')) return;
            lpMoved = false;
            lpTimer = setTimeout(() => {
                lpTimer = null;
                if (!lpMoved) {
                    document.body.classList.add('ui-hidden');
                    if (navigator.vibrate) navigator.vibrate(40);
                }
            }, CONFIG.LONG_PRESS_DURATION);
        }, { passive: true });
        streamEl.addEventListener('touchmove',   () => { lpMoved = true; if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; } }, { passive: true });
        streamEl.addEventListener('touchend',    () => { if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; } }, { passive: true });
        streamEl.addEventListener('touchcancel', () => { if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; } }, { passive: true });
    }
}

// ===================================
// LAYOUT & THEME
// ===================================
function clearThePlot() {
    const stream = document.querySelector('#stream');
    if (!stream) return;
    stream.style.transition = 'opacity 0.2s ease-out';
    stream.style.opacity = '0';
    setTimeout(() => {
        stream.innerHTML = '';
        state.allSentenceElements = [];
        state.gridImages = [];
        state.chapterStartIndices = new Array(chapters.length).fill(-1);
        state.subchapterStartIndices = [];
        state.currentSentenceIndex = -1;
        state.sentencesSeen = new Set();
        state.bracketsOpened = 0;
        state.chaptersRead = new Set();
        updateStats();
        updateChapterProgress();
        buildChapterDropdown();
        stream.style.transition = 'opacity 0.2s ease-in';
        stream.style.opacity = '1';
        const input = document.getElementById('composeInput');
        if (input) input.placeholder = 'Write that thought.';
        document.body.classList.add('compose-mode');
        const toggle = document.getElementById('composeToggle');
        if (toggle) toggle.classList.add('active');
        setTimeout(() => { if (input) input.focus(); }, 350);
        toastBehaviors.setRailDot(false);
    }, 200);
}

function toggleLayout() {
    state.layoutMode = state.layoutMode === 'layered' ? 'split' : 'layered';
    document.body.classList.remove('layout-layered', 'layout-split');
    document.body.classList.add(`layout-${state.layoutMode}`);
    // Re-evaluate image/dimming state for the current sentence after layout switch
    highlightSentence(state.currentSentenceIndex);
}

function showUI() {
    document.body.classList.remove('ui-hidden');
}

function toggleUIVisibility() {
    document.body.classList.remove('ui-concealed');
    document.body.classList.toggle('ui-hidden');
}

function toggleAllBrackets() {
    const triggers = document.querySelectorAll('.bracket-trigger');
    if (!triggers.length) return;
    // Determine intent: if any are collapsed, expand all; otherwise collapse all
    const anyCollapsed = [...triggers].some(t => !t.classList.contains('expanded'));
    triggers.forEach(trigger => {
        const contentId = trigger.getAttribute('aria-controls');
        const content = contentId ? document.getElementById(contentId) : null;
        if (!content) return;
        const isExpanded = content.classList.contains('visible');
        if (anyCollapsed && !isExpanded) {
            content.classList.add('visible');
            trigger.textContent = '[−]';
            trigger.setAttribute('aria-expanded', 'true');
            trigger.setAttribute('aria-label', 'Collapse annotation');
            trigger.classList.add('expanded');
            state.expandedBrackets.add(parseInt(contentId.replace('bracket-content-', '')));
        } else if (!anyCollapsed && isExpanded) {
            content.classList.remove('visible');
            trigger.textContent = '[+]';
            trigger.setAttribute('aria-expanded', 'false');
            trigger.setAttribute('aria-label', 'Expand annotation');
            trigger.classList.remove('expanded');
            state.expandedBrackets.delete(parseInt(contentId.replace('bracket-content-', '')));
        }
    });
    // Sync button active state
    const btn = document.getElementById('modeKeyBrackets');
    if (btn) btn.classList.toggle('mode-active', !anyCollapsed ? false : true);
}

function enterFocusMode() {
    document.body.classList.add('focus-mode');
    hideImage();
    Toast.show({ id: 'focus-mode-on', message: 'Focus Mode — interface hidden, images suspended', duration: 2500, banner: true, force: true });
}

function exitFocusMode() {
    document.body.classList.remove('focus-mode');
    // Tear down cursor thumbnail, re-trigger normal bg image if still hovering
    if (cursor.element && cursor.element.classList.contains('thumb-active')) {
        cursor.element.classList.remove('thumb-active');
        if (cursor.currentImageElement) {
            const url = cursor.currentImageElement.getAttribute('data-image');
            if (url) showImage(url, cursor.currentImageElement);
        }
    }
    Toast.show({ id: 'focus-mode-off', message: 'Focus Mode off', duration: 1800, banner: true, force: true });
}

function toggleFocusMode() {
    if (document.body.classList.contains('focus-mode')) exitFocusMode();
    else enterFocusMode();
}


function toggleTheme() {
    const body = document.body;
    // Add a transitioning flag so grain/edge-blur don't flash during the swap
    body.classList.add('theme-transitioning');
    requestAnimationFrame(() => {
        if (body.classList.contains('theme-sport')) body.classList.remove('theme-sport');
        else if (body.classList.contains('theme-newspaper')) { body.classList.remove('theme-newspaper'); body.classList.add('theme-sport'); }
        else body.classList.add('theme-newspaper');
        const icon = Utils.$('.theme-icon');
        icon.textContent = body.classList.contains('theme-sport') ? '⚡' : (body.classList.contains('theme-newspaper') ? '📖' : '☀️');
        requestAnimationFrame(() => {
            body.classList.remove('theme-transitioning');
        });
    });
}

// ===================================
// ACCESSIBILITY
// ===================================
function initializeAccessibility() {
    let accessibilityLevel = 2;
    const accessibilityLevels = [0, 0.25, 0.5, 0.75, 1];
    function applyAccessibilityLevel(level) {
        const value = accessibilityLevels[level];
        document.documentElement.style.setProperty('--curve-k', value * 3);
        document.documentElement.style.setProperty('--vig-opacity', Math.min(value * 2.4, 1.2));
        document.documentElement.style.setProperty('--edge-blur', (value * 20) + 'px');
        document.body.style.fontSize = ((1.3 - (value * 0.9)) * 100) + '%';
        Utils.$$('.level-indicator').forEach((el, i) => { el.classList.toggle('active', i === level); });
    }
    Utils.$('#accessibilityIncrease').addEventListener('click', () => { if (accessibilityLevel > 0) applyAccessibilityLevel(--accessibilityLevel); });
    Utils.$('#accessibilityDecrease').addEventListener('click', () => { if (accessibilityLevel < accessibilityLevels.length - 1) applyAccessibilityLevel(++accessibilityLevel); });
    applyAccessibilityLevel(accessibilityLevel);
}

// ===================================
// LONG PRESS
// ===================================
function setupLongPress(buttonId, normalAction, longPressAction) {
    const button = Utils.$(`#${buttonId}`);
    if (!button) return;
    let longPressTimer = null;
    let longPressActivated = false;
    button.addEventListener('touchstart', () => {
        longPressActivated = false;
        longPressTimer = setTimeout(() => { longPressActivated = true; longPressAction(); if (navigator.vibrate) navigator.vibrate(50); }, CONFIG.LONG_PRESS_DURATION);
    }, { passive: true });
    button.addEventListener('touchend', (e) => { if (longPressTimer) clearTimeout(longPressTimer); if (longPressActivated) e.preventDefault(); }, { passive: false });
    button.addEventListener('touchcancel', () => { if (longPressTimer) clearTimeout(longPressTimer); }, { passive: true });
    button.addEventListener('click', (e) => { if (longPressActivated) { e.preventDefault(); e.stopPropagation(); longPressActivated = false; } else normalAction(); });
}

// ===================================
// CLOSE HOTSPOTS
// ===================================
function initializeCloseHotspots() {
    const gridCloseHotspot = Utils.$('#gridCloseHotspot');
    const rotateCloseHotspot = Utils.$('#rotateCloseHotspot');
    const rotateWarning = Utils.$('#rotateWarning');
    gridCloseHotspot.addEventListener('mouseenter', () => cursor.element.classList.add('close-mode'));
    gridCloseHotspot.addEventListener('mouseleave', () => cursor.element.classList.remove('close-mode'));
    gridCloseHotspot.addEventListener('click', () => { toggleImageGrid(); cursor.element.classList.remove('close-mode'); });
    rotateCloseHotspot.addEventListener('mouseenter', () => cursor.element.classList.add('close-mode'));
    rotateCloseHotspot.addEventListener('mouseleave', () => cursor.element.classList.remove('close-mode'));
    rotateCloseHotspot.addEventListener('click', () => { rotateWarning.style.display = 'none'; cursor.element.classList.remove('close-mode'); if (state.layoutMode === 'split') toggleLayout(); });

    // ui-hidden hotspot — top-right corner restores UI (same geometry as close-hotspots)
    const uiHiddenHotspot = document.getElementById('uiHiddenHotspot');
    uiHiddenHotspot.addEventListener('mouseenter', () => cursor.element.classList.add('close-mode'));
    uiHiddenHotspot.addEventListener('mouseleave', () => cursor.element.classList.remove('close-mode'));
    uiHiddenHotspot.addEventListener('click', () => { showUI(); cursor.element.classList.remove('close-mode'); });

    // focus-mode hotspot — top-right corner exits focus mode
    const focusModeHotspot = document.getElementById('focusModeHotspot');
    focusModeHotspot.addEventListener('mouseenter', () => cursor.element.classList.add('close-mode'));
    focusModeHotspot.addEventListener('mouseleave', () => cursor.element.classList.remove('close-mode'));
    focusModeHotspot.addEventListener('click', () => { exitFocusMode(); cursor.element.classList.remove('close-mode'); });
    // Mobile tap-to-dismiss on the overlay itself
    rotateWarning.addEventListener('click', () => { rotateWarning.style.display = 'none'; if (state.layoutMode === 'split') toggleLayout(); });
}

// ===================================
// KEYBOARD CONTROLS
// ===================================
function initializeKeyboardControls() {
    const getBtnForKey = (key) => {
        if (key === 'ArrowUp' || key === 'k' || key === 'Backspace') return Utils.$('#prevSentenceBtn');
        if (key === 'ArrowDown' || key === 'j' || key === ' ' || key === 'Space') return Utils.$('#nextSentenceBtn');
        return null;
    };
    // Also flash HUD buttons on key press for visual feedback
    const getHudBtnForKey = (key) => {
        if (key === 'ArrowUp' || key === 'k' || key === 'Backspace' || key === 'ArrowLeft') return Utils.$('#hudPrevBtn');
        if (key === 'ArrowDown' || key === 'j' || key === ' ' || key === 'Space' || key === 'ArrowRight') return Utils.$('#hudNextBtn');
        return null;
    };
    // Get keyboard legend key element for highlighting
    const getKeyElement = (key) => {
        if (key === 'ArrowUp' || key === 'k') return Utils.$('#keyPrevSentence');
        if (key === 'ArrowDown' || key === 'j') return Utils.$('#keyNextSentence');
        if (key === 'ArrowLeft') return Utils.$('#keyPrevChapter');
        if (key === 'ArrowRight') return Utils.$('#keyNextChapter');
        return null;
    };
    document.addEventListener('keydown', e => {
        // ── Compose input guard — don't intercept typing ──
        const active = document.activeElement;
        const isTyping = active && (
            active.tagName === 'TEXTAREA' ||
            active.tagName === 'INPUT' ||
            active.isContentEditable ||
            active.id === 'composeInput' ||
            active.id === 'imagemapUrlInput'
        );
        if (isTyping) return;

        const btn = getBtnForKey(e.key);
        if (btn) btn.classList.add('active-press');
        const hudBtn = getHudBtnForKey(e.key);
        if (hudBtn) hudBtn.classList.add('active-press');
        // Highlight keyboard legend keys
        const keyElement = getKeyElement(e.key);
        if (keyElement) {
            keyElement.style.background = 'var(--accent)';
            keyElement.style.color = '#fff';
            keyElement.style.borderColor = 'var(--accent)';
        }
        
        if (e.key === 'Space' || e.code === 'Space') { e.preventDefault(); nextSentence(); }
        else if (e.key.toLowerCase() === 'g') { e.preventDefault(); toggleImageGrid(); }
        else if (e.key.toLowerCase() === 'c') { e.preventDefault(); toggleChapterDropdown(); }
        else if (e.key === 'Backspace') { e.preventDefault(); previousSentence(); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); nextChapter(); }
        else if (e.key === 'ArrowLeft') { e.preventDefault(); previousChapter(); }
        else if (e.key === 'ArrowDown' || e.key === 'j') { e.preventDefault(); nextSentence(); }
        else if (e.key === 'ArrowUp' || e.key === 'k') { e.preventDefault(); previousSentence(); }
        else if (e.key === 'Shift') { e.preventDefault(); toggleLayout(); }
        else if (e.key === 'l') toggleLayout();
        else if (e.key.toLowerCase() === 't') toggleTheme();
        else if (e.key.toLowerCase() === 'h') { e.preventDefault(); toggleUIVisibility(); }
        else if (e.key.toLowerCase() === 'f') { e.preventDefault(); toggleFocusMode(); }
        else if (e.key === 'Home') { e.preventDefault(); resetToBeginning(); }
        else if (e.key === 'Escape' || e.key.toLowerCase() === 'x') {
            if (document.body.classList.contains('focus-mode')) { exitFocusMode(); return; }
            if (document.body.classList.contains('ui-hidden')) { showUI(); return; }
            closeChapterDropdown();
            if (isGridOpen()) { toggleImageGrid(); cursor.element.classList.remove('close-mode'); }
            else if (Utils.$('#rotateWarning').style.display === 'flex') { Utils.$('#rotateWarning').style.display = 'none'; cursor.element.classList.remove('close-mode'); if (state.layoutMode === 'split') toggleLayout(); }
            else if (state.layoutMode === 'split') toggleLayout();
        }
    });
    document.addEventListener('keyup', e => { 
        const btn = getBtnForKey(e.key); if (btn) btn.classList.remove('active-press');
        const hudBtn = getHudBtnForKey(e.key); if (hudBtn) hudBtn.classList.remove('active-press');
        // Remove highlight from keyboard legend keys
        const keyElement = getKeyElement(e.key);
        if (keyElement) {
            keyElement.style.background = '';
            keyElement.style.color = '';
            keyElement.style.borderColor = '';
        }
    });
}

// ===================================
// INTERACTION HINT
// ===================================
function initializeInteractionHint() {
    let hintDismissed = false;
    const dismissHint = () => { if (!hintDismissed) { document.body.classList.add('hint-shown'); hintDismissed = true; } };
    document.addEventListener('click', dismissHint, { once: true });
    document.addEventListener('touchstart', dismissHint, { once: true });
    setTimeout(dismissHint, 3000);
}

// ===================================
// MAIN INITIALIZATION
// ===================================
document.addEventListener('DOMContentLoaded', () => {

    // ── Page Loader ──
    (function initPageLoader() {
        const loader = document.getElementById('pageLoader');
        if (!loader) return;
        // Dismiss after content is ready + brief cinematic hold
        function dismissLoader() {
            loader.classList.add('fade-out');
            setTimeout(() => { loader.remove(); }, 700);
        }
        // Dismiss after 2.6s minimum — long enough to feel cinematic, short enough to not annoy
        const MIN_DISPLAY = 2600;
        const startTime = Date.now();
        function tryDismiss() {
            const elapsed = Date.now() - startTime;
            const remaining = Math.max(0, MIN_DISPLAY - elapsed);
            setTimeout(dismissLoader, remaining);
        }
        if (document.readyState === 'complete') {
            tryDismiss();
        } else {
            window.addEventListener('load', tryDismiss, { once: true });
            // Safety: dismiss at 5s no matter what
            setTimeout(dismissLoader, 5000);
        }
    })();

    cursor.element = Utils.$('#cursor');
    
    document.addEventListener('mousemove', e => {
        cursor.targetX = e.clientX; cursor.targetY = e.clientY;
        state.mouseX = e.clientX; state.mouseY = e.clientY;
    }, { passive: true });
    
    document.addEventListener('mouseover', e => {
        if (e.target.matches('a, button, .image-trigger, input[type="range"], .chapter-break, .chapter-item, .grid-image-item, .k-key')) {
            cursor.element.classList.add('hovering');
            if (e.target.matches('button, a, .grid-image-item, .k-key')) cursor.element.classList.add('pointer');
        }
    }, { passive: true });
    
    document.addEventListener('mouseout', e => {
        if (e.target.matches('a, button, .image-trigger, input[type="range"], .chapter-break, .chapter-item, .grid-image-item, .k-key')) {
            cursor.element.classList.remove('hovering', 'pointer');
        }
    }, { passive: true });
    
    detectTouch();
    initializeAccessibility();
    initializeContextMenu();
    initializeCloseHotspots();
    initializeKeyboardControls();

    // Tab-nav detection — sentence focus ring only shows during Tab navigation
    document.addEventListener('keydown', e => {
        if (e.key === 'Tab') document.body.setAttribute('data-tab-nav', '');
        else document.body.removeAttribute('data-tab-nav');
    });
    document.addEventListener('mousedown', () => document.body.removeAttribute('data-tab-nav'));
    document.addEventListener('touchstart', () => document.body.removeAttribute('data-tab-nav'), { passive: true });
    initializeInteractionHint();
    
    // Initialize draggable widgets using factory
    const legend = document.getElementById('keyboardLegend');
    if (legend) {
        makeDraggable(legend, { useRight: true, useBottom: true });
        Utils.$('#keyPrevSentence').addEventListener('click', (e) => { e.stopPropagation(); previousSentence(); });
        Utils.$('#keyNextSentence').addEventListener('click', (e) => { e.stopPropagation(); nextSentence(); });
        Utils.$('#keyPrevChapter').addEventListener('click', (e) => { e.stopPropagation(); previousChapter(); });
        Utils.$('#keyNextChapter').addEventListener('click', (e) => { e.stopPropagation(); nextChapter(); });
    }
    
    // Stats Widget Logic
    const statsWidget = document.getElementById('statsWidget');
    if (statsWidget) {
        let lastDesktopLeft = '80px';
        let lastDesktopBottom = '20px';
        let isMobileMode = window.innerWidth <= 768;

        const applyDesktopStyles = () => {
             statsWidget.style.left = lastDesktopLeft;
             statsWidget.style.bottom = lastDesktopBottom;
             statsWidget.style.right = 'auto'; // clear mobile styles
             statsWidget.style.transform = ''; // clear mobile centering
             statsWidget.style.width = ''; // clear mobile width
             statsWidget.style.margin = ''; // clear mobile margin
             statsWidget.style.cursor = 'grab';
        };

        const applyMobileStyles = () => {
             // Save desktop position before switching to mobile layout
             if (statsWidget.style.left && statsWidget.style.left !== '0px') lastDesktopLeft = statsWidget.style.left;
             if (statsWidget.style.bottom) lastDesktopBottom = statsWidget.style.bottom;
             
             // Apply mobile layout override
             statsWidget.style.left = '0'; 
             statsWidget.style.right = '0';
             statsWidget.style.bottom = 'calc(16px + env(safe-area-inset-bottom))';
             statsWidget.style.marginLeft = 'auto';
             statsWidget.style.marginRight = 'auto';
             statsWidget.style.width = 'fit-content';
             statsWidget.style.transform = 'none';
             statsWidget.style.cursor = 'default';
        };

        // Initialize Draggable ONCE
        makeDraggable(statsWidget, { useRight: false, useBottom: true });

        // Set Initial State
        if (isMobileMode) applyMobileStyles();
        else applyDesktopStyles();

        // Resize Listener
        window.addEventListener('resize', Utils.debounce(() => {
            const newIsMobile = window.innerWidth <= 768;
            if (newIsMobile !== isMobileMode) {
                isMobileMode = newIsMobile;
                if (isMobileMode) applyMobileStyles();
                else applyDesktopStyles();
            }
        }, 100));
    }
    
    // Event listeners
    Utils.$('#brandLogo').addEventListener('click', toggleChapterDropdown);
    Utils.$('#gridToggleBtn')?.addEventListener('click', toggleImageGrid);
    Utils.$('#layoutToggle')?.addEventListener('click', toggleLayout);
    Utils.$('#themeToggle')?.addEventListener('click', toggleTheme);

    // Mode cluster buttons
    const modeCluster = document.getElementById('modeCluster');
    if (modeCluster) {
        makeDraggable(modeCluster, { useRight: true, useBottom: false });

        Utils.$('#modeKeyCompose').addEventListener('click', (e) => { e.stopPropagation(); if (window.toggleCompose) window.toggleCompose(); });
        Utils.$('#modeKeyG').addEventListener('click', (e) => { e.stopPropagation(); toggleImageGrid(); });
        Utils.$('#modeKeyF').addEventListener('click', (e) => { e.stopPropagation(); toggleFocusMode(); });
        Utils.$('#modeKeyH').addEventListener('click', (e) => { e.stopPropagation(); toggleUIVisibility(); });
        Utils.$('#modeKeyT').addEventListener('click', (e) => { e.stopPropagation(); toggleTheme(); });
        Utils.$('#modeKeyL').addEventListener('click', (e) => { e.stopPropagation(); toggleLayout(); });
        Utils.$('#modeKeyBrackets').addEventListener('click', (e) => { e.stopPropagation(); toggleAllBrackets(); });

        // Sync active states when modes change
        function syncModeCluster() {
            Utils.$('#modeKeyCompose')?.classList.toggle('mode-active', document.body.classList.contains('compose-mode'));
            Utils.$('#modeKeyF').classList.toggle('mode-active', document.body.classList.contains('focus-mode'));
            Utils.$('#modeKeyH').classList.toggle('mode-active', document.body.classList.contains('ui-hidden'));
            Utils.$('#modeKeyG').classList.toggle('mode-active', isGridOpen());
            const isLayered = document.body.classList.contains('layout-layered');
            Utils.$('#modeKeyL').classList.toggle('mode-active', !isLayered);
            const allExpanded = document.querySelectorAll('.bracket-trigger').length > 0 &&
                [...document.querySelectorAll('.bracket-trigger')].every(t => t.classList.contains('expanded'));
            Utils.$('#modeKeyBrackets')?.classList.toggle('mode-active', allExpanded);
        }
        // Observe body class changes to keep buttons in sync
        new MutationObserver(syncModeCluster).observe(document.body, { attributes: true, attributeFilter: ['class'] });
        syncModeCluster();
    }
    Utils.$('#prevSentenceBtn').addEventListener('click', () => { state.lastNavWasKeyboard = false; previousSentence(); });
    Utils.$('#nextSentenceBtn').addEventListener('click', () => { state.lastNavWasKeyboard = false; nextSentence(); });
    
    document.addEventListener('click', e => {
        if (!Utils.$('#brandLogo').contains(e.target) && !Utils.$('#chapterDropdown').contains(e.target) && !e.target.closest('.chapter-break')) closeChapterDropdown();
    });
    
    function clearConcealed() { document.body.classList.remove('ui-concealed'); }
    ['keydown','wheel','touchstart','click'].forEach(ev =>
        document.addEventListener(ev, clearConcealed, { once: true, passive: true }));
    window.addEventListener('wheel', handleScroll, { passive: false });
    window.addEventListener('touchstart', handleTouchStart, { passive: true });
    window.addEventListener('touchmove', handleTouchMove, { passive: false });
    window.addEventListener('touchend', handleTouchEnd, { passive: true });
    
    // Toast: wire wheel events (both rapid and single-wheel detection)
    window.addEventListener('wheel', () => {
        toastBehaviors.onWheel();
        toastBehaviors.onSingleWheel();
    }, { passive: true });

    // Toast: mark that user has used keyboard or nav buttons (not scroll-only)
    document.addEventListener('keydown', (e) => {
        const navKeys = ['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','j','k'];
        if (navKeys.includes(e.key) || navKeys.includes(e.code)) toastBehaviors.onKeyOrButton();
        else toastBehaviors.onKeyOrButton(); // any keypress resets idle
    }, { passive: true });
    Utils.$('#prevSentenceBtn')?.addEventListener('click', () => toastBehaviors.onKeyOrButton(), { passive: true });
    Utils.$('#nextSentenceBtn')?.addEventListener('click', () => toastBehaviors.onKeyOrButton(), { passive: true });
    Utils.$('#hudPrevBtn')?.addEventListener('click', () => toastBehaviors.onKeyOrButton(), { passive: true });
    Utils.$('#hudNextBtn')?.addEventListener('click', () => toastBehaviors.onKeyOrButton(), { passive: true });
    
    // Wire HUD nav buttons with long-press (prev/next sentence, long-press for chapter)
    setupLongPress('hudPrevBtn', previousSentence, previousChapter);
    setupLongPress('hudNextBtn', nextSentence, nextChapter);
    setupLongPress('landPrevBtn', previousSentence, previousChapter);
    setupLongPress('landNextBtn', nextSentence, nextChapter);
    
    preloadImages();
    render();
    updateStats(); // Initialize stats display
    updateCursor();
    updateParallax();
    
    document.body.classList.add(`layout-${state.layoutMode}`);
    
    if (state.allSentenceElements.length > 0) {
        state.currentSentenceIndex = 0;
        highlightSentence(0);
    }
    
    // Initialize draggable dropdown after render
    initializeDraggableDropdown();
    
    window.toggleLayout = toggleLayout;
    window.toggleTheme = toggleTheme;
    
    // Initialize toast system
    toastBehaviors.init();

    // Sync theme icon to match default newspaper theme
    const themeIconEl = Utils.$('.theme-icon');
    if (themeIconEl) themeIconEl.textContent = '📖';

    // Rail bell button — cycles through ambient pool, force-shows even if already seen
    const toastRailBtn = document.getElementById('toastRailBtn');
    if (toastRailBtn) {
        let forceIndex = 0;
        toastRailBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const pool = toastBehaviors.getAmbientPool();
            // First try unshown toasts; if all shown, cycle with force
            const unshown = pool.filter(t => !Toast.hasShown(t.id) && (!t.condition || t.condition()));
            const pick = unshown.length > 0
                ? unshown[Math.floor(Math.random() * unshown.length)]
                : pool[forceIndex++ % pool.length];
            toastBehaviors.clearAmbientTimer();
            toastBehaviors.setRailDot(true);
            Toast.show({
                id: pick.id,
                icon: pick.icon,
                message: typeof pick.message === 'function' ? pick.message() : pick.message,
                actionLabel: pick.actionLabel || null,
                actionFn: pick.actionFn || null,
                duration: 12000,
                force: true,
                onDismiss: () => toastBehaviors.setRailDot(false)
            });
        });
    }

    // ===================================
    // COMPOSE MODE
    // ===================================
    (function initCompose() {

        // ── State ──
        const compose = {
            active: false,
            editingIndex: -1,       // -1 = new sentence, ≥0 = editing existing
            editingPhrase: null,    // phrase selected for image mapping
            writerSentences: 0,
            writerBrackets: 0,
            writerWords: 0,
            liveImageMap: {}        // user-added phrase → url mappings
        };

        // ── Elements ──
        const toggle     = document.getElementById('composeToggle');
        const bar        = document.getElementById('composeBar');
        const input      = document.getElementById('composeInput');
        const commit     = document.getElementById('composeCommit'); // desktop only (not in DOM, kept for compat)
        const chapterSel = document.getElementById('composeChapterSelect');
        const wordCount  = document.getElementById('composeWordCount');
        const hudSubmit  = document.getElementById('hudSubmitBtn');   // mobile HUD submit
        const mobileClose = document.getElementById('composeMobileClose');
        const hintsBtn   = document.getElementById('composeHintsBtn');
        const picker     = document.getElementById('imagemapPicker');
        const pickerClose= document.getElementById('imagemapPickerClose');
        const pickerPhrase = document.getElementById('imagemapPickerPhrase');
        const urlInput   = document.getElementById('imagemapUrlInput');
        const urlConfirm = document.getElementById('imagemapUrlConfirm');
        const imgGrid    = document.getElementById('imagemapGrid');
        const clusterBracket = document.getElementById('composeKeyBracket');
        const clusterSection = document.getElementById('composeKeySubchapter');
        const clusterBreak   = document.getElementById('composeKeyBreak');
        const clusterChapter = document.getElementById('composeKeyChapter');
        const clusterImage   = document.getElementById('composeKeyImage');
        const clusterDelete  = document.getElementById('composeKeyDelete');
        const clusterTheme   = document.getElementById('modeKeyTCompose');

        // ── Populate chapter select ──
        function populateChapterSelect() {
            if (!chapterSel) return;
            chapterSel.innerHTML = '';
            chapters.forEach(ch => {
                const opt = document.createElement('option');
                opt.value = ch.id;
                opt.textContent = `${String(ch.id + 1).padStart(2,'0')}. ${ch.title}`;
                chapterSel.appendChild(opt);
            });
            // Default to current chapter
            chapterSel.value = state.currentChapterIndex || 0;
        }

        // ── Toggle compose mode ──
        // ── HUD nudge helpers ──
        function nudgeHudAboveBar() {
            if (window.innerWidth > 768) return;
            const barH = bar.getBoundingClientRect().height;
            if (barH > 0) statsWidget.style.bottom = `calc(${barH}px + 12px + env(safe-area-inset-bottom))`;
        }

        function restoreHud() {
            if (window.innerWidth > 768) return;
            statsWidget.style.bottom = 'calc(16px + env(safe-area-inset-bottom))';
        }

        function enterCompose() {
            compose.active = true;
            composeActive = true;
            document.body.classList.add('compose-mode');
            if (toggle) toggle.classList.add('active');
            const hudCompose = document.getElementById('hudComposeBtn');
            if (hudCompose) hudCompose.classList.add('active');
            populateChapterSelect();
            updateWordCount();
            syncWriterStats();
            setTimeout(() => {
                input.focus();
                nudgeHudAboveBar();
            }, 350);
            syncComposeCluster();
        }

        function exitCompose() {
            compose.active = false;
            composeActive = false;
            compose.editingIndex = -1;
            document.body.classList.remove('compose-mode');
            if (toggle) toggle.classList.remove('active');
            const hudCompose = document.getElementById('hudComposeBtn');
            if (hudCompose) hudCompose.classList.remove('active');
            Utils.$$('.sentence.editing').forEach(s => s.classList.remove('editing'));
            restoreHud();
            syncComposeCluster();
        }

        function toggleCompose() {
            if (compose.active) exitCompose(); else enterCompose();
        }
        window.toggleCompose = toggleCompose;

        if (toggle) toggle.addEventListener('click', toggleCompose);

        // HUD compose button (mobile — reader mode)
        const hudCompose = document.getElementById('hudComposeBtn');
        if (hudCompose) hudCompose.addEventListener('click', toggleCompose);

        // HUD submit button (mobile — compose mode)
        if (hudSubmit) {
            hudSubmit.disabled = true;
            hudSubmit.addEventListener('click', commitSentence);
        }

        // Close button inside compose bar
        if (mobileClose) mobileClose.addEventListener('click', exitCompose);

        // Hints tooltip button → fires a toast on mobile
        if (hintsBtn) {
            hintsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                Toast.show({
                    id: `compose-hints-${Date.now()}`,
                    icon: '⌨️',
                    message: '<span class="toast-accent">Enter</span> commit &nbsp;·&nbsp; <span class="toast-accent">Shift+Enter</span> line break &nbsp;·&nbsp; <span class="toast-accent">###</span> subchapter &nbsp;·&nbsp; <span class="toast-accent">dbl-tap</span> sentence to edit',
                    duration: 10000,
                    force: true
                });
            });
        }

        // ── Input state ──
        input.addEventListener('input', () => {
            const hasContent = input.value.trim().length > 0;
            if (hudSubmit) hudSubmit.disabled = !hasContent;
            updateWordCount();
            // Auto-resize
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 180) + 'px';
            // Keep HUD above compose bar as it grows
            nudgeHudAboveBar();
        });

        // ResizeObserver keeps HUD above bar even if bar height changes for other reasons
        if (typeof ResizeObserver !== 'undefined') {
            new ResizeObserver(() => { if (compose.active) nudgeHudAboveBar(); }).observe(bar);
        }

        function updateWordCount() {
            const words = input.value.trim().split(/\s+/).filter(Boolean).length;
            const sentences = state.allSentenceElements.filter(s => !s.dataset.structural).length;
            if (wordCount) wordCount.textContent = `${words} word${words !== 1 ? 's' : ''} · ${sentences} sentence${sentences !== 1 ? 's' : ''}`;
        }

        function syncWriterStats() {
            const sentences = state.allSentenceElements.filter(s => !s.dataset.structural).length;
            const sentVal = document.getElementById('statSentencesSeen');
            if (sentVal) {
                sentVal.textContent = sentences;
                sentVal.classList.add('pulse');
                setTimeout(() => sentVal.classList.remove('pulse'), 400);
            }
        }

        // ── Commit sentence ──
        function commitSentence() {
            const raw = input.value.trim();
            if (!raw) return;

            const stream = Utils.$('#stream');
            if (!stream) return;

            if (compose.editingIndex >= 0) {
                // ── Edit existing sentence ──
                const el = state.allSentenceElements[compose.editingIndex];
                if (el) {
                    const elType = el.dataset.type;
                    if (elType === 'chapter' || elType === 'section') {
                        // Re-parse the edited value as the appropriate structural type
                        const prefix = elType === 'chapter' ? '###:' : '##:';
                        const editRaw = raw.startsWith(prefix) ? raw : prefix + raw;
                        const title = editRaw.substring(prefix.length).trim().replace(/\.$/, '') + '.';
                        const displayTitle = title.replace(/\.$/, '');
                        el.dataset.title = displayTitle;
                        el.classList.remove('editing');

                        if (elType === 'chapter') {
                            const chId = parseInt(el.dataset.chapterId);
                            if (chapters[chId]) chapters[chId].title = displayTitle;
                            el.innerHTML = `<span class="chapter-number">Chapter ${String(chId + 1).padStart(2, '0')}</span><span class="chapter-title">${displayTitle}</span>`;
                            buildChapterDropdown();
                        } else {
                            el.innerHTML = `<span class="subchapter-title">${displayTitle}</span>`;
                            const sub = state.subchapterStartIndices.find(s => s.sentenceIndex === parseInt(el.dataset.sentenceIndex));
                            if (sub) sub.title = displayTitle;
                        }
                        highlightSentence(compose.editingIndex);
                    } else {
                        el.innerHTML = wrapImageTriggers(raw) + ' ';
                        el.classList.remove('editing');
                        highlightSentence(compose.editingIndex);
                    }
                }
                compose.editingIndex = -1;
                input.value = '';
                input.style.height = 'auto';
                if (hudSubmit) hudSubmit.disabled = true;
                updateWordCount();
                return;
            }

            // ── Insert new sentence ──
            // ###: Chapter break
            if (raw.startsWith('###:')) {
                const rawTitle = raw.substring(4).trim();
                const title = rawTitle.replace(/\.$/, '') + '.'; // auto-period
                const displayTitle = title.replace(/\.$/, '');
                const newChapterId = chapters.length;
                chapters.push({ id: newChapterId, title: displayTitle, startText: null });
                const idx = state.allSentenceElements.length;
                state.chapterStartIndices.push(idx);
                const chapterBreak = document.createElement('div');
                chapterBreak.className = 'chapter-break';
                chapterBreak.dataset.chapterId = newChapterId;
                chapterBreak.dataset.type = 'chapter';
                chapterBreak.dataset.structural = 'true';
                chapterBreak.dataset.sentenceIndex = idx;
                chapterBreak.dataset.title = displayTitle;
                chapterBreak.innerHTML = `<span class="chapter-number">Chapter ${String(newChapterId + 1).padStart(2, '0')}</span><span class="chapter-title">${displayTitle}</span>`;
                chapterBreak.addEventListener('click', () => { showUI(); openDropdownFromChapterBreak(chapterBreak, newChapterId); });
                chapterBreak.addEventListener('dblclick', () => { if (!composeActive) return; beginEdit(parseInt(chapterBreak.dataset.sentenceIndex)); });
                stream.appendChild(chapterBreak);
                state.allSentenceElements.push(chapterBreak);
                buildChapterDropdown();
                updateChapterProgress();
                input.value = '';
                input.style.height = 'auto';
                if (hudSubmit) hudSubmit.disabled = true;
                updateWordCount();
                Toast.show({ id: `chapter-added-${Date.now()}`, icon: '📖', message: `Chapter ${newChapterId + 1}: <span class="toast-accent">${displayTitle}</span> added`, duration: 3000, force: true });
                return;
            }

            // ##: Subchapter break
            if (raw.startsWith('##:')) {
                const rawTitle = raw.substring(3).trim();
                const displayTitle = rawTitle.replace(/\.$/, '');
                const idx = state.allSentenceElements.length;
                const el = document.createElement('div');
                el.className = 'subchapter-break';
                el.dataset.type = 'section';
                el.dataset.structural = 'true';
                el.dataset.sentenceIndex = idx;
                el.dataset.title = displayTitle;
                el.innerHTML = `<span class="subchapter-title">${displayTitle}</span>`;
                el.addEventListener('dblclick', () => { if (!composeActive) return; beginEdit(parseInt(el.dataset.sentenceIndex)); });
                state.subchapterStartIndices.push({ sentenceIndex: idx, title: displayTitle });
                stream.appendChild(el);
                state.allSentenceElements.push(el);
                input.value = '';
                input.style.height = 'auto';
                if (hudSubmit) hudSubmit.disabled = true;
                updateWordCount();
                return;
            }

            // #: Line break
            if (raw === '#:' || raw.startsWith('#:')) {
                const br = document.createElement('span');
                br.className = 'line-break-spacer';
                br.innerHTML = '<br>';
                stream.appendChild(br);
                // Any text after #: becomes a new sentence
                const remainder = raw.substring(2).trim();
                if (remainder) {
                    input.value = remainder;
                    commitSentence();
                    return;
                }
                input.value = '';
                input.style.height = 'auto';
                if (hudSubmit) hudSubmit.disabled = true;
                updateWordCount();
                return;
            }

            // Build sentence element
            const idx = state.allSentenceElements.length;
            const span = document.createElement('span');
            span.className = 'sentence just-added';
            span.dataset.sentenceIndex = idx;
            span.style.cursor = 'pointer';
            span.setAttribute('tabindex', '0');
            span.setAttribute('role', 'button');
            span.setAttribute('aria-label', `Sentence ${idx + 1}: ${raw}`);

            // Check if any live imageMap phrases are in this sentence
            for (const [phrase, url] of Object.entries(compose.liveImageMap)) {
                if (raw.includes(phrase)) {
                    imageMap[phrase] = url;
                    phraseRegexMap.set(phrase, buildPhraseRegex(phrase));
                    break;
                }
            }

            span.innerHTML = wrapImageTriggers(raw) + ' ';

            // Double-click to edit in compose mode
            span.addEventListener('dblclick', () => {
                if (!compose.active) return;
                beginEdit(parseInt(span.dataset.sentenceIndex));
            });

            span.addEventListener('mouseenter', () => {
                if (state.isTouch) return;
                const index = parseInt(span.dataset.sentenceIndex);
                state.allSentenceElements.forEach((s, i) => {
                    s.style.opacity = i === index ? '0.7' : '0.25';
                });
            }, { passive: true });
            span.addEventListener('mouseleave', () => {
                if (state.isTouch) return;
                state.allSentenceElements.forEach(s => s.style.opacity = '');
            }, { passive: true });
            span.addEventListener('click', () => {
                state.currentSentenceIndex = parseInt(span.dataset.sentenceIndex);
                highlightSentence(state.currentSentenceIndex);
            });
            span.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (compose.active) { beginEdit(parseInt(span.dataset.sentenceIndex)); return; }
                    state.currentSentenceIndex = parseInt(span.dataset.sentenceIndex);
                    highlightSentence(state.currentSentenceIndex);
                }
            });

            stream.appendChild(span);
            state.allSentenceElements.push(span);

            // Attach drag-reorder handle if in compose mode
            if (compose.active && window._attachSentenceDrag) window._attachSentenceDrag(span);

            // Remove animation class after it fires
            setTimeout(() => span.classList.remove('just-added'), 500);

            // Auto-navigate to new sentence
            state.currentSentenceIndex = idx;
            highlightSentence(idx);

            // Update chapter dropdown + progress
            buildChapterDropdown();
            updateChapterProgress();

            // Update image hover listeners on stream
            rewireStreamImageListeners();

            compose.writerSentences++;
            syncWriterStats();

            input.value = '';
            input.style.height = 'auto';
            if (hudSubmit) hudSubmit.disabled = true;
            updateWordCount();

            // Scroll new sentence into view
            span.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Re-focus input
            setTimeout(() => input.focus(), 50);
        }

        // ── Begin edit ──
        function beginEdit(index) {
            const el = state.allSentenceElements[index];
            if (!el) return;
            Utils.$$('.sentence.editing, .chapter-break.editing, .subchapter-break.editing').forEach(s => s.classList.remove('editing'));
            compose.editingIndex = index;
            el.classList.add('editing');

            // Pre-fill with the appropriate prefix for structural elements
            let prefilled;
            if (el.dataset.type === 'chapter') {
                const title = (el.dataset.title || '').replace(/\.$/, '');
                prefilled = `###:${title}`;
            } else if (el.dataset.type === 'section') {
                const title = (el.dataset.title || '').replace(/\.$/, '');
                prefilled = `##:${title}`;
            } else {
                prefilled = el.textContent.replace(/\s+/g, ' ').trim();
            }

            input.value = prefilled;
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 180) + 'px';
            if (hudSubmit) hudSubmit.disabled = false;
            input.focus();
            input.select();
            highlightSentence(index);
        }

        // ── Delete active sentence ──
        function deleteActiveSentence() {
            const idx = state.currentSentenceIndex;
            if (idx < 0 || idx >= state.allSentenceElements.length) return;
            const el = state.allSentenceElements[idx];
            if (!el) return;

            const isChapter = el.dataset.type === 'chapter';
            const isSection = el.dataset.type === 'section';
            const label = isChapter ? `chapter "${el.dataset.title}"` : isSection ? `section "${el.dataset.title}"` : `sentence ${idx + 1}`;
            if (!confirm(`Delete ${label}?`)) return;

            el.remove();
            state.allSentenceElements.splice(idx, 1);

            // If it was a chapter, remove from chapters[] and rebuild chapterStartIndices
            if (isChapter) {
                const chId = parseInt(el.dataset.chapterId);
                chapters.splice(chId, 1);
                // Re-assign ids sequentially
                chapters.forEach((ch, i) => { ch.id = i; });
                // Rebuild chapterStartIndices from remaining chapter-break elements
                state.chapterStartIndices = new Array(chapters.length).fill(-1);
                state.allSentenceElements.forEach((s, i) => {
                    if (s.dataset.type === 'chapter') {
                        const cid = parseInt(s.dataset.chapterId);
                        // Re-assign chapterId after splice
                        const newCid = chapters.findIndex(c => c.title === s.dataset.title);
                        if (newCid >= 0) {
                            s.dataset.chapterId = newCid;
                            state.chapterStartIndices[newCid] = i;
                            s.querySelector('.chapter-number').textContent = `Chapter ${String(newCid + 1).padStart(2, '0')}`;
                        }
                    }
                });
                buildChapterDropdown();
            }

            // If it was a section, remove from subchapterStartIndices
            if (isSection) {
                const sIdx = parseInt(el.dataset.sentenceIndex);
                const pos = state.subchapterStartIndices.findIndex(s => s.sentenceIndex === sIdx);
                if (pos >= 0) state.subchapterStartIndices.splice(pos, 1);
            }

            // Re-index remaining elements
            state.allSentenceElements.forEach((s, i) => {
                s.dataset.sentenceIndex = i;
                if (!s.dataset.structural) {
                    s.setAttribute('aria-label', `Sentence ${i + 1}: ${s.textContent.trim()}`);
                }
            });

            const newIdx = Math.min(idx, state.allSentenceElements.length - 1);
            state.currentSentenceIndex = newIdx;
            if (newIdx >= 0) highlightSentence(newIdx);
            buildChapterDropdown();
            updateChapterProgress();
            syncWriterStats();
            updateWordCount();
        }

        // ── Drag-to-reorder sentences in compose mode ──
        (function initSentenceDragReorder() {
            let dragSrcEl = null;

            // All draggable unit selectors (sentences + structural + bracket wrappers)
            const DRAG_SEL = '.sentence, .chapter-break, .subchapter-break, .bracket-drag-unit';

            function getHandle(el) {
                let h = el.querySelector(':scope > .sentence-drag-handle');
                if (!h) {
                    h = document.createElement('span');
                    h.className = 'sentence-drag-handle';
                    h.setAttribute('aria-hidden', 'true');
                    h.textContent = '⠿';
                    el.insertBefore(h, el.firstChild);
                }
                return h;
            }

            function clearDropClasses() {
                Utils.$$(DRAG_SEL).forEach(s => s.classList.remove('drag-over-above', 'drag-over-below'));
            }

            function reindex() {
                const streamEl = Utils.$('#stream');
                if (!streamEl) return;
                const domOrder = Array.from(streamEl.querySelectorAll(DRAG_SEL));
                state.allSentenceElements = domOrder.filter(el => !el.classList.contains('bracket-drag-unit'));
                // Re-index allSentenceElements sequentially
                state.allSentenceElements.forEach((s, i) => {
                    s.dataset.sentenceIndex = i;
                    if (!s.dataset.structural) {
                        s.setAttribute('aria-label', `Sentence ${i + 1}: ${s.textContent.replace(/⠿/g,'').trim()}`);
                    }
                });
            }

            function attachDrag(el) {
                if (el._dragAttached) return;
                el._dragAttached = true;

                const handle = getHandle(el);

                handle.addEventListener('mousedown', () => { el.draggable = true; }, { passive: true });
                handle.addEventListener('touchstart', () => { el.draggable = true; }, { passive: true });
                document.addEventListener('mouseup', () => { el.draggable = false; }, { passive: true });

                el.addEventListener('dragstart', (e) => {
                    if (!compose.active) { e.preventDefault(); return; }
                    dragSrcEl = el;
                    el.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', '1');
                });

                el.addEventListener('dragend', () => {
                    el.classList.remove('dragging');
                    el.draggable = false;
                    clearDropClasses();
                    dragSrcEl = null;
                });

                el.addEventListener('dragover', (e) => {
                    if (!dragSrcEl || dragSrcEl === el) return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    clearDropClasses();
                    const rect = el.getBoundingClientRect();
                    el.classList.add(e.clientY < rect.top + rect.height / 2 ? 'drag-over-above' : 'drag-over-below');
                });

                el.addEventListener('dragleave', () => {
                    el.classList.remove('drag-over-above', 'drag-over-below');
                });

                el.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (!dragSrcEl || dragSrcEl === el) return;
                    const before = el.classList.contains('drag-over-above');
                    clearDropClasses();
                    el.parentNode.insertBefore(dragSrcEl, before ? el : el.nextSibling);
                    reindex();
                    dragSrcEl.classList.add('just-added');
                    setTimeout(() => dragSrcEl && dragSrcEl.classList.remove('just-added'), 450);
                    updateWordCount();
                    buildChapterDropdown();
                    updateChapterProgress();
                    syncWriterStats();
                });
            }

            // Wrap loose bracket-trigger+bracket-content pairs into a single draggable unit
            function wrapBrackets() {
                const streamEl = Utils.$('#stream');
                if (!streamEl) return;
                const triggers = Array.from(streamEl.querySelectorAll('.bracket-trigger:not([data-wrapped])'));
                triggers.forEach(trigger => {
                    const content = trigger.nextElementSibling;
                    if (!content || !content.classList.contains('bracket-content')) return;
                    const wrapper = document.createElement('span');
                    wrapper.className = 'bracket-drag-unit sentence'; // give it .sentence for compose CSS
                    wrapper.dataset.bracketUnit = 'true';
                    trigger.setAttribute('data-wrapped', '1');
                    trigger.parentNode.insertBefore(wrapper, trigger);
                    wrapper.appendChild(trigger);
                    wrapper.appendChild(content);
                    attachDrag(wrapper);
                });
            }

            // Unwrap bracket units back to loose pairs on exit
            function unwrapBrackets() {
                const streamEl = Utils.$('#stream');
                if (!streamEl) return;
                Array.from(streamEl.querySelectorAll('.bracket-drag-unit')).forEach(wrapper => {
                    const parent = wrapper.parentNode;
                    while (wrapper.firstChild) parent.insertBefore(wrapper.firstChild, wrapper);
                    wrapper.remove();
                });
                Utils.$$('.bracket-trigger[data-wrapped]').forEach(t => t.removeAttribute('data-wrapped'));
            }

            // Expose for new sentences
            window._attachSentenceDrag = attachDrag;

            // Patch enterCompose / exitCompose
            const _origEnter = enterCompose;
            const _origExit  = exitCompose;

            enterCompose = function() {
                _origEnter();
                wrapBrackets();
                state.allSentenceElements.forEach(el => attachDrag(el));
                // Also attach to any bracket wrappers just created
                Utils.$$('.bracket-drag-unit').forEach(el => attachDrag(el));
            };

            exitCompose = function() {
                _origExit();
                unwrapBrackets();
            };

            window.toggleCompose = function() { if (compose.active) exitCompose(); else enterCompose(); };
        })();

        // ── Commit on Enter (not Shift+Enter) ──
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                commitSentence();
            }
            // Navigation keys still work in compose mode
            if (e.key === 'ArrowUp' && e.metaKey) { e.preventDefault(); previousSentence(); }
            if (e.key === 'ArrowDown' && e.metaKey) { e.preventDefault(); nextSentence(); }
        });

        // ── Bracket annotation quick-insert ──
        function insertBracket() {
            const pos = input.selectionStart;
            const val = input.value;
            const bracketed = val.slice(0, pos) + ' [annotation text] ' + val.slice(pos);
            input.value = bracketed;
            // Select "annotation text" for immediate replacement
            const start = pos + 2;
            const end = start + 15;
            input.focus();
            input.setSelectionRange(start, end);
            if (hudSubmit) hudSubmit.disabled = false;
        }

        if (clusterBracket) clusterBracket.addEventListener('click', (e) => { e.stopPropagation(); insertBracket(); input.focus(); });

        // ── Chapter quick-insert ──
        if (clusterChapter) clusterChapter.addEventListener('click', (e) => {
            e.stopPropagation();
            input.value = '###:';
            input.focus();
            // Place cursor after the colon
            input.setSelectionRange(4, 4);
            if (hudSubmit) hudSubmit.disabled = false;
        });

        // ── Subchapter quick-insert ──
        if (clusterSection) clusterSection.addEventListener('click', (e) => {
            e.stopPropagation();
            input.value = '##:';
            input.focus();
            if (hudSubmit) hudSubmit.disabled = false;
        });

        // ── Pull-quote quick-insert ──
        const clusterPullquote = document.getElementById('composeKeyPullquote');
        if (clusterPullquote) clusterPullquote.addEventListener('click', (e) => {
            e.stopPropagation();
            input.value = '>>:Wolfie|';
            input.focus();
            input.setSelectionRange(10, 10);
            if (hudSubmit) hudSubmit.disabled = false;
        });

        // ── Line break quick-insert ──
        if (clusterBreak) clusterBreak.addEventListener('click', (e) => {
            e.stopPropagation();
            input.value = '#:';
            if (hudSubmit) hudSubmit.disabled = false;
            commitSentence();
        });

        // ── Delete ──
        if (clusterDelete) clusterDelete.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteActiveSentence();
        });

        // ── Theme in compose ──
        if (clusterTheme) clusterTheme.addEventListener('click', (e) => { e.stopPropagation(); toggleTheme(); });

        // ── Image mapping ──
        function openImagePicker() {
            // Get selected text in input or active sentence
            const selectedText = window.getSelection().toString().trim() ||
                                  input.value.substring(input.selectionStart, input.selectionEnd).trim();

            const phrase = selectedText || (compose.editingIndex >= 0
                ? state.allSentenceElements[compose.editingIndex]?.textContent.trim().split(' ').slice(0,3).join(' ')
                : input.value.trim().split(' ').slice(0,3).join(' '));

            compose.editingPhrase = phrase || 'selected phrase';
            pickerPhrase.textContent = `"${compose.editingPhrase}"`;
            urlInput.value = '';

            // Populate grid with existing imageMap entries
            imgGrid.innerHTML = '';
            const entries = Object.entries(imageMap);
            if (entries.length === 0) {
                imgGrid.innerHTML = '<p style="font-family:var(--ui-font);font-size:10px;color:var(--ink-3);letter-spacing:0.06em;grid-column:1/-1;">No images in library yet. Paste a URL above to add one.</p>';
            } else {
                entries.forEach(([p, url]) => {
                    const item = document.createElement('div');
                    item.className = 'imagemap-grid-item';
                    const isVid = url.match(/\.mp4(\?|$)/i);
                    const mediaEl = isVid
                        ? `<video src="${url}" muted autoplay loop playsinline preload="metadata" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;border-radius:4px;"></video>`
                        : `<img src="${url}" alt="" loading="lazy">`;
                    item.innerHTML = `${mediaEl}<span class="item-phrase">${p}</span>`;
                    item.addEventListener('click', () => applyImageMap(url));
                    imgGrid.appendChild(item);
                });
            }

            picker.classList.add('open');
            picker.setAttribute('aria-hidden', 'false');
            urlInput.focus();
        }

        function closeImagePicker() {
            picker.classList.remove('open');
            picker.setAttribute('aria-hidden', 'true');
            compose.editingPhrase = null;
            if (compose.active) setTimeout(() => input.focus(), 100);
        }

        function applyImageMap(url) {
            if (!compose.editingPhrase || !url) return;
            const phrase = compose.editingPhrase;
            imageMap[phrase] = url;
            compose.liveImageMap[phrase] = url;
            phraseRegexMap.set(phrase, buildPhraseRegex(phrase));

            // Re-render the current sentence's image triggers if it contains the phrase
            const el = state.allSentenceElements[state.currentSentenceIndex];
            if (el && el.textContent.includes(phrase)) {
                const plain = el.textContent.replace(/\s+/g, ' ').trim();
                el.innerHTML = wrapImageTriggers(plain) + ' ';
                rewireStreamImageListeners();
                highlightSentence(state.currentSentenceIndex);
            }

            closeImagePicker();
            Toast.show({ id: `imgmap-${Date.now()}`, icon: '🖼', message: `Image mapped to "<span class="toast-accent">${phrase.substring(0,30)}</span>"`, duration: 4000, force: true });
        }

        if (clusterImage) clusterImage.addEventListener('click', (e) => { e.stopPropagation(); openImagePicker(); });
        pickerClose.addEventListener('click', closeImagePicker);
        picker.addEventListener('click', (e) => { if (e.target === picker) closeImagePicker(); });

        urlConfirm.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) applyImageMap(url);
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); const url = urlInput.value.trim(); if (url) applyImageMap(url); }
            if (e.key === 'Escape') closeImagePicker();
        });

        // ── Rewire stream image listeners after DOM mutations ──
        function rewireStreamImageListeners() {
            const streamEl = Utils.$('#stream');
            if (!streamEl) return;
            // Remove old delegated listeners by cloning node children — cheaper: just re-trigger on hover
            // The existing delegated listeners on streamEl already handle .image-trigger via bubbling
            // Just make sure preloadImages picks up new ones
            const newUrls = Object.values(compose.liveImageMap);
            newUrls.forEach(url => { if (!url.match(/\.mp4(\?|$)/i)) { const img = new Image(); img.src = url; } });
        }

        // ── Double-click existing sentences to edit in compose mode ──
        Utils.$('#stream').addEventListener('dblclick', (e) => {
            if (!compose.active) return;
            const sentence = e.target.closest('.sentence');
            if (!sentence) return;
            const idx = parseInt(sentence.dataset.sentenceIndex);
            if (!isNaN(idx)) beginEdit(idx);
        });

        // ── Sync compose cluster active states ──
        function syncComposeCluster() {
            if (clusterImage) clusterImage.classList.toggle('mode-active', !!compose.editingPhrase);
        }

        // ── Escape closes compose bar ──
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && compose.active && !picker.classList.contains('open')) {
                exitCompose();
            }
            if (e.key === 'Escape' && picker.classList.contains('open')) {
                closeImagePicker();
            }
        });

        // ── Keyboard shortcut: Cmd/Ctrl+E toggles compose ──
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
                e.preventDefault();
                toggleCompose();
            }
        });

    })();

    // Make compose bar draggable on desktop
    (function() {
        const composeBar = document.getElementById('composeBar');
        const handle = document.getElementById('composeDragHandle');
        if (!composeBar || !handle) return;

        let isDragging = false;
        let startX, startY, startLeft, startBottom;

        function getPos() {
            const rect = composeBar.getBoundingClientRect();
            startLeft = rect.left;
            startBottom = window.innerHeight - rect.bottom;
        }

        function applyDragPos(left, bottom) {
            const rect = composeBar.getBoundingClientRect();
            const w = rect.width || 600;
            const h = rect.height || 160;
            const margin = 8;
            left = Math.max(margin, Math.min(left, window.innerWidth - w - margin));
            bottom = Math.max(margin, Math.min(bottom, window.innerHeight - h - margin));
            composeBar.style.left = left + 'px';
            composeBar.style.bottom = bottom + 'px';
            composeBar.style.transform = 'none';
        }

        handle.addEventListener('mousedown', (e) => {
            if (window.innerWidth <= 768) return;
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            getPos();
            composeBar.style.transition = 'opacity 0.35s ease';
            handle.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = startY - e.clientY;
            applyDragPos(startLeft + dx, startBottom + dy);
        });

        document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            handle.style.cursor = 'grab';
            composeBar.style.transition = 'transform 0.35s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.35s ease';
        });
    })();

    // ===================================
    // MUSIC PLAYER
    // ===================================
    (function initMusicPlayer() {
        const TRACKS = [
            { name: 'Walk with Wolfie', sub: 'original — guitar',        url: 'https://soundcloud.com/zackgort/walk-with-wolfie' },
            { name: 'Day Dream',         sub: 'original — guitar',        url: 'https://soundcloud.com/zackgort/dreamdog' },
            { name: 'Beautiful Day',    sub: 'cover concept — guitar & midi drums', url: 'https://soundcloud.com/zackgort/beautifulday' },
            { name: 'Bad Touch',        sub: 'cover concept — guitar',        url: 'https://soundcloud.com/zackgort/badtouch' },
        ];

        let currentTrack = -1;
        let isPlaying    = false;
        let widget       = null;
        let iframe       = null;
        let widgetReady  = false;
        let expanded     = false;

        const player        = document.getElementById('musicPlayer');
        const dragHandle    = document.getElementById('musicPlayerDrag');
        const collapseBtn   = document.getElementById('musicPlayerCollapse');
        const headerPlayBtn = document.getElementById('musicHeaderPlay');
        const headerIcon    = document.getElementById('musicHeaderIcon');
        const playBtn       = document.getElementById('musicPlayBtn');
        const playIcon      = document.getElementById('musicPlayIcon');
        const prevBtn       = document.getElementById('musicPrevBtn');
        const nextBtn       = document.getElementById('musicNextBtn');
        const nowName       = document.getElementById('musicNowName');
        const nowStatus     = document.getElementById('musicNowStatus');
        const container     = document.getElementById('musicIframeContainer');
        const trackEls      = document.querySelectorAll('.music-track');

        // ── Expand / Collapse — simple, robust, no state entanglement ──
        function setExpanded(val) {
            expanded = val;
            player.classList.toggle('expanded', expanded);
            collapseBtn.textContent = expanded ? '▴' : '▾';
            collapseBtn.title = expanded ? 'Hide tracks' : 'Show tracks';
        }

        // Collapse button: use both click AND touchend to guarantee Android response
        function onCollapseInteraction(e) {
            e.preventDefault();
            e.stopPropagation();
            setExpanded(!expanded);
        }
        collapseBtn.addEventListener('click',    onCollapseInteraction);
        collapseBtn.addEventListener('touchend', onCollapseInteraction, { passive: false });

        // Sentence click collapses track list
        document.addEventListener('click', (e) => {
            if (e.target.closest && e.target.closest('.sentence') && expanded) setExpanded(false);
        });

        // ── Drag — bottom-center default, free after first drag ──
        (function enableDrag() {
            let dragging = false, startX, startY, startLeft, startTop;

            function beginDrag(clientX, clientY) {
                // Snap from CSS centering to absolute coords
                if (!player.classList.contains('dragged')) {
                    const box = player.getBoundingClientRect();
                    player.classList.add('dragged');
                    player.style.left   = box.left + 'px';
                    player.style.top    = box.top  + 'px';
                    player.style.bottom = 'auto';
                    player.style.right  = 'auto';
                    player.style.transform = 'none';
                }
                dragging = true;
                startX = clientX; startY = clientY;
                startLeft = parseFloat(player.style.left) || 0;
                startTop  = parseFloat(player.style.top)  || 0;
            }
            function moveDrag(clientX, clientY) {
                if (!dragging) return;
                player.style.left = Math.max(0, Math.min(startLeft + clientX - startX, window.innerWidth  - player.offsetWidth))  + 'px';
                player.style.top  = Math.max(0, Math.min(startTop  + clientY - startY, window.innerHeight - player.offsetHeight)) + 'px';
            }

            dragHandle.addEventListener('mousedown', (e) => {
                if (e.target.closest('.music-btn, .music-player-collapse, .music-header-playpause')) return;
                e.preventDefault();
                beginDrag(e.clientX, e.clientY);
                dragHandle.style.cursor = 'grabbing';
            });
            document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
            document.addEventListener('mouseup',   ()  => { dragging = false; dragHandle.style.cursor = 'grab'; });

            dragHandle.addEventListener('touchstart', (e) => {
                if (e.target.closest('.music-btn, .music-player-collapse, .music-header-playpause')) return;
                const t = e.touches[0];
                beginDrag(t.clientX, t.clientY);
            }, { passive: true });
            document.addEventListener('touchmove', (e) => {
                if (!dragging) return;
                const t = e.touches[0];
                moveDrag(t.clientX, t.clientY);
            }, { passive: true });
            document.addEventListener('touchend', () => { dragging = false; });
        })();

        // ── Icon helpers ──
        const PLAY_PATH  = '<path d="M8 5v14l11-7z"/>';
        const PAUSE_PATH = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';

        function setPlayIcons(playing) {
            playIcon.innerHTML   = playing ? PAUSE_PATH : PLAY_PATH;
            headerIcon.innerHTML = playing ? PAUSE_PATH : PLAY_PATH;
        }
        function setStatus(text, playing) {
            nowStatus.textContent = text;
            nowStatus.classList.toggle('playing', !!playing);
        }
        function setNowName(name) {
            nowName.textContent = name || '♪ Wolfies Walklist';
        }

        // ── Load track ──
        function loadTrack(index, autoplay) {
            currentTrack = index;
            trackEls.forEach((el, i) => {
                el.classList.toggle('active', i === index);
                el.querySelector('.music-track-num').textContent = i + 1;
            });
            setNowName(TRACKS[index].name);
            setStatus('loading…', false);
            setPlayIcons(false);

            if (iframe) { iframe.remove(); iframe = null; widget = null; widgetReady = false; }

            const src = 'https://w.soundcloud.com/player/?url=' + encodeURIComponent(TRACKS[index].url) +
                '&color=%23daa520&auto_play=' + autoplay +
                '&hide_related=true&show_comments=false&show_user=false&show_reposts=false&show_teaser=false&visual=false';
            iframe = document.createElement('iframe');
            iframe.src = src;
            iframe.width = '100%'; iframe.height = '166';
            iframe.scrolling = 'no'; iframe.frameBorder = 'no'; iframe.allow = 'autoplay';
            container.appendChild(iframe);

            function wire() {
                if (!iframe || !window.SC) return;
                widget = window.SC.Widget(iframe);
                widget.bind(window.SC.Widget.Events.READY, () => {
                    widgetReady = true;
                    if (autoplay) widget.play(); else setStatus('ready', false);
                });
                widget.bind(window.SC.Widget.Events.PLAY, () => {
                    isPlaying = true; setPlayIcons(true); setStatus('playing', true);
                    if (currentTrack >= 0) trackEls[currentTrack].querySelector('.music-track-num').textContent = '▶';
                });
                widget.bind(window.SC.Widget.Events.PAUSE, () => {
                    isPlaying = false; setPlayIcons(false); setStatus('paused', false);
                    if (currentTrack >= 0) trackEls[currentTrack].querySelector('.music-track-num').textContent = currentTrack + 1;
                });
                widget.bind(window.SC.Widget.Events.FINISH, () => {
                    isPlaying = false; setPlayIcons(false);
                    if (currentTrack >= 0) trackEls[currentTrack].querySelector('.music-track-num').textContent = currentTrack + 1;
                    loadTrack((currentTrack + 1) % TRACKS.length, true);
                });
                widget.bind(window.SC.Widget.Events.ERROR, () => setStatus('unavailable', false));
            }

            if (window.SC && window.SC.Widget) { wire(); }
            else if (!document.getElementById('sc-widget-api')) {
                const s = document.createElement('script');
                s.id = 'sc-widget-api'; s.src = 'https://w.soundcloud.com/player/api.js'; s.onload = wire;
                document.head.appendChild(s);
            } else {
                const poll = setInterval(() => { if (window.SC && window.SC.Widget) { clearInterval(poll); wire(); } }, 80);
            }
        }

        // ── Play / Pause ──
        function playPause() {
            if (currentTrack === -1) { loadTrack(0, true); return; }
            if (!widget || !widgetReady) return;
            if (isPlaying) widget.pause(); else widget.play();
        }

        // ── Event wiring ──
        function bindBtn(el, fn) {
            el.addEventListener('click',    (e) => { e.stopPropagation(); fn(); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); fn(); }, { passive: false });
        }
        bindBtn(playBtn,       playPause);
        bindBtn(headerPlayBtn, playPause);
        bindBtn(prevBtn, () => loadTrack(currentTrack <= 0 ? TRACKS.length - 1 : currentTrack - 1, isPlaying));
        bindBtn(nextBtn, () => loadTrack(currentTrack === -1 ? 0 : (currentTrack + 1) % TRACKS.length, isPlaying));

        trackEls.forEach((el, i) => {
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentTrack === i) playPause(); else loadTrack(i, true);
            });
            el.addEventListener('touchend', (e) => {
                e.preventDefault(); e.stopPropagation();
                if (currentTrack === i) playPause(); else loadTrack(i, true);
            }, { passive: false });
        });

    })();


});
    </script>
</body>
</html>
